<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式系统一致性算法 - Raft</title>
    <link href="/2020/12/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Raft/"/>
    <url>/2020/12/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-Raft/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Raft是用于管理复制日志的共识算法. 它产生的结果等效于 multi-Paxos, 它的效率与Paxos相同, 但其结构与Paxos不同. 这使Raft比Paxos更易于理解, 并且为构建实用系统提供了更好的基础. 为了增强可理解性, Raft分离了共识的关键要素, 例如领导人选举, 日志复制和安全性, 并强制实施了更高程度的一致性以减少必须考虑的状态数. 一项用户研究的结果表明, 与Paxos相比, 筏更易于学生学习. Raft还包括用于更改集群成员资格的新机制, 该机制使用重叠的多数来保证安全</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><blockquote><p>状态机: 对外保证一致性的数据</p><p>日志: 保存了所有修改记录</p><p>一致性模块: 一致性模块算法就是用来保证写入的log的命令的一致性(核心内容)</p><p>客户端发起更新请求 -&gt; leader 发起同步事件(append) -&gt; 同步完成(commit) -&gt; 应用状态机(apply) -&gt; 返回客户端<br>ps: 如果超时, 客户端将带着 requestId 重试. 同样, leader 发起同步事件也是幂等操作</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gleexhsi8uj31k90u0jxi.jpg" alt="image-20201206203405980"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gleeme6cacj30u00zgnik.jpg" alt="image-20201206202323839"></p><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><blockquote><p>所有节点持久化的属性:</p><ol><li>currentTerm: 服务器的最新term(首次启动时初始化为0, 单调增加)</li><li>votedFor: 在当前任期内获得投票的候选人ID(如果没有, 则为null)</li><li>logs[]: 本地日志(索引从 1 开始)</li></ol><p>所有节点非持久化的属性:</p><ol><li>commitIndex: 已提交(过半 follower 同步的日志)的最高日志条目的索引(初始化为0, 单调增加)</li><li>lastApplied: 应用于状态机的最高日志条目的索引(初始化为0, 单调增加, 一定小于等于 commitIndex)</li></ol><p>leader 的属性:</p><ol><li>nextIndex[]: 各个 follower 节点同步的下一个节点(初始化为leader 的最大索引)</li><li>matchIndex[]: 各个 follower 节点的匹配节点(这个位置之前的日志所有节点都是一致的, 初始化为 0)</li></ol><p>规则:</p><ol><li>如果 commitIndex &gt; lastApplied, 则说明需要将已同步的日志应用于状态机, 然后更新 lastApplied</li><li>如果 同步事件返回的 term &gt; currentTerm, 则退回为 follower(此时状态为 leader 或者 candidate)</li></ol></blockquote><h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h4><blockquote><p>副本集中只会存在一个 leader. leader 负责客户端的所有更新请求. </p><p>规则: </p><ol><li>成为 leader 后, 发送心跳事件给所有服务, 防止重复选举</li><li>从收到客户端指令, 同步 follower 并且 apply 状态机后, 相应客户端</li><li>如果 follower 的last log index ≥ nextIndex, 则说明 follower 之前的日志需要替换, 将该 follower 的 nextIndex-1 再同步该 follower(重复直到相同, 保证 follower 的数据和 leader 一致)</li><li>如果同步数据成功, 则需更新对应 follower 的 nextIndex 和 matchIndex</li><li>如果过半 follower 的 commitIndex &gt; N, 则将 commitIndex 更新为 N</li></ol></blockquote><h4 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h4><blockquote><p>普通副本, 接收leader 的更新请求, 更新 log</p></blockquote><h4 id="candidate"><a href="#candidate" class="headerlink" title="candidate"></a>candidate</h4><blockquote><p>选举者. 当探活发现和 leader 断联, 则从 follower 状态切换为 candidate, 发起选举</p></blockquote><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><blockquote><p>更新记录</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="AppendEntries-RPC"><a href="#AppendEntries-RPC" class="headerlink" title="AppendEntries RPC"></a>AppendEntries RPC</h4><blockquote><p>leader 发起的同步日志事件和心跳事件(心跳extries 为空)</p><p>参数: </p><ol><li>term: leader 任期号(递增)</li><li>leaderId: leader id(方便客户端发起更新请求, 重定向至 leader 节点)</li><li>prevLogIndex: 同步日志的前一条日志索引(安全校验, 保证前一个元素下标相同)</li><li>prevLogTerm: 同步日志的前一条日志元素(安全校验, 保证前一个元素相同)</li><li>entries[]: 同步的日志列表</li><li>leaderCommit: leader 的 commitIndex(如果 follower 小于 leader, 则同步为 leader 的 commitIndex, 并将区间的日志 apply 状态机)</li></ol><p>结果:</p><ol><li>term: 当前节点的 leader 任期号</li><li>success: 是否成功</li></ol><p>如果 term &lt; currentTerm, 则说明 leader 已失效, 返回 false 让他更新为 follower 状态<br>如果 prevLogIndex 的 prevLogTerm 和本地的不一致, 则说明本地的数据需要同步为 leader 的数据, 返回 false. 让 leader 索引前移再来请求<br>其他情况则将本地数据替换为 leader 数据<br>如果leaderCommit &gt; 本地 commitIndex, 则说明数据已 commit, 需要将本地的 commitInde x更新为leaderCommit</p></blockquote><h4 id="RequestVote-RPC"><a href="#RequestVote-RPC" class="headerlink" title="RequestVote RPC"></a>RequestVote RPC</h4><blockquote><p>candidate 发起的投票选举事件</p><p>参数:</p><ol><li>term: 候选人任期</li><li>candidateId: 候选人 Id</li><li>lastLogIndex: 候选人最新日志索引</li><li>lastLogTerm: 候选人最新的日志元素</li></ol><p>结果:</p><ol><li>term: follower 的 term</li><li>voteGranted: true 则说明投票给候选人</li></ol><p>如果 term 小于 当前 follower term 则说明该候选人没有当前 follower 日志更新, 返回 false<br>如果 lastLogIndex 小于当前 follower 日志索引, 则说明已经有更新的 leader, 返回 false<br>如果 lastLogTerm 和当前 follower 日志元素不同, 则返回 false</p></blockquote><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gleewu8dj8j31tq0rmdmy.jpg" alt="image-20201206203328487"></p><blockquote><p>选举超时事件为一个固定区间的随机值(最大限度降低竞争)<br>节点的每个 term 至允许投票一次(先到先得)<br>candidate 当接收到 leader 的 term &gt; currentTerm, 则退回 follower<br>cndidate 当接收到 leader 的 term &lt; currentTerm, 则拒绝同意, 等待超时, 重新发起选举</p><ol><li>首先所有节点初始化都为 follower, 并且启动定时器, 超时没有收到消息, 则需要转换状态为 candidate, </li><li>将 currentTerm(初始化为 0) + 1并且发起投票选举事件<ol><li>如果赢得选举, 则切换为 leaderl 状态</li><li>其他节点赢得选举, 则自己变为 follower</li><li>没有获胜者, 则等待然后currentTerm + 1, 再次发起投票选举事件</li></ol></li></ol></blockquote><h2 id="快照-日志压缩"><a href="#快照-日志压缩" class="headerlink" title="快照(日志压缩)"></a>快照(日志压缩)</h2><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1glef4qo9y8j31e50u0wj3.jpg" alt="image-20201206204103843"></p><blockquote><p>随着时间推移, 日志一定会无比巨大, 如果有一个 follower 和 leader 日志差异较大, 则需要leader 一直回退 nextIndex 重试, 效率低下. 并且由于状态机不关注过程, 只在乎最终态, 因此可以定期将状态机的数据生成快照, 来提升启动效率和节省磁盘空间(可参考 Redis 持久化方式 rdb 和 aof 思想)</p><p>快照可由 follower 自己生成(降低由 leader 发送至 follower 的网络占用), 也可有 leader 发送至 follower(当 follower 落后过多时)</p><p>如果 leader 发送的 follower 的最后一条日志在 follower 中存在, 则 follower 可放弃该快照</p><p>由于生成 snapshot 涉及 IO 操作, 为了提高效率采用 COW(CopyOnWrite)来保证生成快照期间的日志同步同样不会丢失</p></blockquote><h4 id="leader-发送快照"><a href="#leader-发送快照" class="headerlink" title="leader 发送快照"></a>leader 发送快照</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1glefdjb0ouj30u0148wlv.jpg" alt="image-20201206204930367"></p><blockquote><p>leader 发送同步快照事件</p><p>参数:</p><ol><li>term: 当前任期</li><li>leaderId: leaderId</li><li>lastIncludedIndex: 快照的最后一个索引</li><li>lastIncludedTerm: 快照的最后一个元素</li><li>offset: 快照文件中块所在位置的字节偏移量</li><li>data[]: 快照块的原始字节，从偏移量开始</li><li>done: 如果这是最后一块, 则为 true</li></ol><p>结果: </p><ol><li>term: 当前节点的 leader 任期号</li></ol><p>如果term &lt;currentTerm，请立即回复<br>如果第一个块（偏移量为0），则创建新的快照文件<br>以给定的偏移量将数据写入快照文件<br>如果done为false，则回复并等待更多数据块<br>保存快照文件，丢弃索引较小的任何现有或部分快照<br>如果现有日志条目的索引和术语与快照的最后一个包含的条目相同，请保留其后的日志条目并回复<br>丢弃整个日志<br>使用快照内容重置状态机（并加载快照的集群配置）</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="简单同步"><a href="#简单同步" class="headerlink" title="简单同步"></a>简单同步</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1glefnfx5nwj314n0u0dm9.jpg" alt="image-20201206205900735"></p><blockquote><p>假设 leader 一直未变动(实际发生三次选举, 只不过每次同步数据过程没有数据同步冲突). 各个节点的同步情况可能如上图情况. 此时第 2, 4, 5 节点可能因为网络原因导致未跟上 leader 的同步. 假设此时 leader 发起同步, leader 的第二个节点logIndex[1].index &#x3D; 8 , 那么他会发起同步事件给第二个节点, 第二个节点会返回 false, 此时 leader 将第二个节点logIndex[1].index - 1 &#x3D; 7, 再次发起同步事件, 还会 false, 直到 index &#x3D; 5, 此时第二个节点才会执行同步, 返回 true</p></blockquote><h3 id="复杂同步"><a href="#复杂同步" class="headerlink" title="复杂同步"></a>复杂同步</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1glefo3f5doj31ad0u0dm4.jpg" alt="image-20201206205939520"></p><blockquote><p>最复杂的情况为上图. 图中可得总过发生过 7 次选举. 观察 f 可发现, 可得出 term &#x3D; 2 时, 追加了 222, 然后再次发生选举, term &#x3D; 3, 追加33333 日志, 但是两次皆未同步至其他节点(也可能是没有过半节点同步, 导致新的选举节点将数据同步覆盖)便宕机, 此时选举结果为 term &#x3D; 4, 并且a, b, c, d, e皆同步数据. 此时又发生选举 term &#x3D; 5 -&gt; 6, 当 leader 变为 7 时(仍然数据未同步过半)宕机, 发生选举重新回到 leader(最上方, 即将为 term &#x3D; 8). 此时 leader 发起数据同步, 会将其他节点数据同步为leader 数据. 至于 d, f 节点的数据将会重置并覆盖</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://image.baidu.com/search/down?url=http://www.jianshu.com/p/0e695b4be92f">简书-Raft系列</a></p><p><a href="https://image.baidu.com/search/down?url=http://juejin.cn/post/6844903657540943880">掘金-Raft算法分析与实现</a></p><p><a href="https://raft.github.io/raft.pdf">官方论文-Raft Paper</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>一致性算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>一致性</tag>
      
      <tag>CAP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 知识汇总</title>
    <link href="/2020/02/16/Kafka%20%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2020/02/16/Kafka%20%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列, 可以处理大量的数据, 并使您能够将消息从一个端点传递到另一个端点.  Kafka适合离线和在线消息消费.  Kafka消息保留在磁盘上, 并在群集内复制以防止数据丢失.  Kafka构建在ZooKeeper同步服务之上.  它与Apache Storm和Spark非常好地集成, 用于实时流式数据分析. </p><p>Kafka 依赖于日志顺序写,  因此支持消息回溯和支撑高性能读写</p><p>依赖 Zookeeper</p></blockquote><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4bbra5jj314f0u0ae0.jpg" alt="image-20200216165335332"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><blockquote><p>Server. 包含多个 Topic , Partition, 和 Replica. 负责协调 Producer 和 Consumer</p><p>主从结构为: 主节点为 Controller, 从节点为从节点<br>Kafka 启动是会往 Zookeeper 中注册当前 Broker 信息. 谁先注册谁就是 Controller. 读取注册上来的从节点的数据(通过监听机制), 生成集群的元数据信息, 之后把这些信息都分发给其他的服务器, 让其他服务器能感知到集群中其它成员的存在</p></blockquote><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><blockquote><p>标准 MQ 中的 Queue. Kafka 中一个 Topic 的消息会保存在不同的 Partition (不同的 Broker)来保证高可用</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4bfghsmj310u0tq40m-20230318165952150.jpg" alt="image-20200216164921324"></p><h3 id="Partition-分区"><a href="#Partition-分区" class="headerlink" title="Partition (分区)"></a>Partition (分区)</h3><blockquote><p>可以理解为将标准 MQ 的 Queue 的消息进行拆分, 来实现高可用</p><p>Producer 发送的 Message, 根据 key 和 partition 数进行 hash, 然后进行投递</p><p>一个分区只能被同一个 Consumer Group 中的一个 Consumer 消费. 分区内消费有序</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4bj79a8j30go0853yz.jpg" alt="kafka 顺序写磁盘"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4bm3tb0j31190u0jtw.jpg" alt="image-20200216165004222"></p><h3 id="Replica-备份"><a href="#Replica-备份" class="headerlink" title="Replica (备份)"></a>Replica (备份)</h3><blockquote><p>每一个 Partition 的备份. Replica 的小于等于 Broker 的数量</p><p>Leader: Replica领导节点, 每一个 Partition 都有对应的 Leader 节点(Broker). Producer 写数据时, 只会往 Leader 中写. Consumer 读数据也是从 Leader 中读<br>Follower: Replica跟随节点, 用于复制领导节点的数据. 复制 Leader 消息采用 pull (拉)模式</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># Broker 设置副本数量 默认为 3</span><br><span class="hljs-literal">default</span>.replication.factor<br><br><span class="hljs-meta"># Topic 设置副本数量</span><br>replication-factor<br></code></pre></td></tr></table></figure></blockquote><h4 id="ISR-In-Sync-Replica"><a href="#ISR-In-Sync-Replica" class="headerlink" title="ISR (In-Sync Replica)"></a>ISR (In-Sync Replica)</h4><blockquote><p>Leader维护一个与其基本保持同步的Replica列表, 每个Partition都会有一个ISR, 而且是由leader动态维护.<br>如果一个flower比一个leader落后太多, 或者超过一定时间未发起数据复制请求, 则leader将其重ISR中移除.<br>当ISR中所有Replica都向Leader发送ACK时, leader才commit</p><p>Leader 宕机之后, 会从 ISR 选择数据最新的 Follower 来当做 Leader<br>如果 ISR 全部宕机, 则选择第一个回复的 Replica 当做 Leader 节点 (消息可能会丢失或者重复消费)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">rerplica.lag.time.max.ms</span>=<span class="hljs-number">10000</span><br><span class="hljs-comment"># 如果leader发现flower超过10秒没有向它发起fech请求, 那么leader考虑这个flower是不是程序出了点问题</span><br><span class="hljs-comment"># 或者资源紧张调度不过来, 它太慢了, 不希望它拖慢后面的进度, 就把它从ISR中移除. </span><br><br><span class="hljs-attr">rerplica.lag.max.messages</span>=<span class="hljs-number">4000</span> <br><span class="hljs-comment"># 相差4000条就移除</span><br><span class="hljs-comment"># flower慢的时候, 保证高可用性, 同时满足这两个条件后又加入ISR中, </span><br><span class="hljs-comment"># 在可用性与一致性做了动态平衡   亮点</span><br><br><span class="hljs-attr">min.insync.replicas</span>=<span class="hljs-number">1</span> <br><span class="hljs-comment"># 需要保证ISR中至少有多少个replica</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="水印备份机制"><a href="#水印备份机制" class="headerlink" title="水印备份机制"></a>水印备份机制</h4><blockquote><p>LEO (last end offset): 日志末端位移, 记录了该副本对象底层日志文件中下一条消息的位移值, 副本写入消息的时候, 会自动更新 LEO 值<br>Leader 会保存两个 LEO 值, 一个是自己的 LEO 值, 另外一个是 remote 的 LEO 值. Follower 每次 fetch 请求都会携带当前 LEO, Leader 会选择最小的 LEO 来更新 HW</p><p>HW (high watermark): 从名字可以知道, 该值叫高水印值, HW 一定不会大于 LEO 值, 小于 HW 值的消息被认为是”已提交”或”已备份”的消息, 并对消费者可见</p><p>备份机制对于各种复杂情况参考: <a href="https://image.baidu.com/search/down?url=http://mp.weixin.qq.com/s/WSdebVgIpvJ_c4DpFYqO4w">图解：Kafka 水印备份机制</a></p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki4bqedwpj31o00dedh7.jpg" alt="image-20200216180322930"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4buedqaj31nq0i00v9.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4bxak7cj30xy0u0mzo.jpg" alt="image-20200216180352412"></p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><blockquote><p>标准 MQ 的 Queue 中的 Message. 即一条消息</p></blockquote><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><blockquote><p>标准 MQ 中的发送方. 发送给 Broker 使用push (推)模式</p></blockquote><h4 id="数据一致性保证-消息不丢失"><a href="#数据一致性保证-消息不丢失" class="headerlink" title="数据一致性保证 (消息不丢失)"></a>数据一致性保证 (消息不丢失)</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">request.required.<span class="hljs-attribute">asks</span>=0<br><span class="hljs-comment"># 0:相当于异步的, 不需要leader给予回复, producer立即返回, 发送就是成功,</span><br>那么发送消息网络超时或broker crash(1.Partition的Leader还没有commit消息 2.Leader与Follower数据不同步), 既有可能丢失也可能会重发<br><span class="hljs-comment"># 1：当leader接收到消息之后发送ack, 丢会重发, 丢的概率很小</span><br><span class="hljs-comment"># -1：当所有的follower都同步消息成功后发送ack. 不会丢失消息</span><br></code></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><blockquote><p>标准 MQ 中的消费方. 接受 Broker 使用 pull (拉)模式, 默认 100ms 拉一次. Consumer 消费的是 Partition 的数据</p><p>消息丢失: 手动确认 ack 而不是自动提交<br>消息重复: 消费端幂等处理</p></blockquote><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><blockquote><p>在 Kafka 中, 一个 Topic 是可以被一个消费组消费, 一个Topic 分发给 Consumer Group 中的 Consumer 进行消费, 保证同一条 Message 不会被不同的 Consumer 消费</p><p>注意: 当Consumer Group的 Consumer 数量大于 Partition 的数量时, 超过 Partition 的数量将会拿不到消息</p></blockquote><h2 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h2><blockquote><p>Kafka分配Replica的算法有两种: RangeAssignor 和 RoundRobinAssignor</p><p>默认为RangeAssignor: </p><ol><li>将所有Broker(假设共n个Broker)和待分配的Partition排序</li><li>将第i个Partition分配到第(i mod n)个Broker上</li><li>将第i个Partition的第j个Replica分配到第((i + j) mod n)个Broker上</li></ol></blockquote><h2 id="Rebalance-重平衡"><a href="#Rebalance-重平衡" class="headerlink" title="Rebalance (重平衡)"></a>Rebalance (重平衡)</h2><blockquote><p>Rebalance 本质上是一种协议, 规定了一个 Consumer Group 下的所有 consumer 如何达成一致,来分配订阅 Topic 的每个分区</p><p>Rebalance 发生时, 所有的 Consumer Group 都停止工作, 知道 Rebalance 完成</p></blockquote><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><blockquote><p>Group Coordinator 是一个服务, 每个 Broker 在启动的时候都会启动一个该服务<br>Group Coordinator 的作用是用来存储 Group 的相关 Meta 信息, 并将对应 Partition 的 Offset 信息记录到 Kafka 内置 Topic(__consumer_offsets)中<br>Kafka 在0.9之前是基于 Zookeeper 来存储Partition的 offset 信息(consumers&#x2F;{group}&#x2F;offsets&#x2F;{topic}&#x2F;{partition}), 因为 Zookeeper 并不适用于频繁的写操作, 所以在0.9之后通过内置 Topic 的方式来记录对应 Partition 的 offset</p></blockquote><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><blockquote><ol><li>组成员个数发生变化<ol><li>新的消费者加入到消费组</li><li>消费者主动退出消费组</li><li>消费者被动下线. 比如消费者长时间的GC, 网络延迟导致消费者长时间未向Group Coordinator发送心跳请求, 均会认为该消费者已经下线并踢出</li></ol></li><li>订阅的 Topic 的 Consumer Group 个数发生变化</li><li>Topic 的分区数发生变化</li></ol></blockquote><h3 id="Rebalace-流程"><a href="#Rebalace-流程" class="headerlink" title="Rebalace 流程"></a>Rebalace 流程</h3><blockquote><p>Rebalance 过程分为两步：Join 和 Sync</p><ol><li>Join: 顾名思义就是加入组. 这一步中, 所有成员都向 Coordinator 发送 JoinGroup 请求, 请求加入消费组. 一旦所有成员都发送了 JoinGroup 请求, Coordinator 会从中选择一个 Consumer 担任 Leader 的角色, 并把组成员信息以及订阅信息发给 Consumer Leader<br> 注意Consumer Leader 和 Coordinator不是一个概念. Consumer Leader负责消费分配方案的制定</li><li>Sync: Consumer Leader 开始分配消费方案, 即哪个 Consumer 负责消费哪些 Topic 的哪些 Partition. 一旦完成分配, Leader 会将这个方案封装进 SyncGroup 请求中发给 Coordinator, 非 Leader 也会发 SyncGroup 请求, 只是内容为空. Coordinator 接收到分配方案之后会把方案塞进SyncGroup的Response中发给各个Consumer. 这样组内的所有成员就都知道自己应该消费哪些分区了</li></ol><p>各个场景参考: <a href="https://image.baidu.com/search/down?url=http://www.cnblogs.com/yoke/p/11405397.html">Kafka Rebalance机制分析</a></p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4c2hquxj31ca0j0wh7-20230318165925057.jpg" alt="image-20200216183957973"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4c5rfz9j31d40l0gp4.jpg" alt="image-20200216184024119"></p><h3 id="如何避免-Rebalance"><a href="#如何避免-Rebalance" class="headerlink" title="如何避免 Rebalance"></a>如何避免 Rebalance</h3><blockquote><p>对于触发条件的 2 和 3, 我们可以人为避免. 1 中的 1 和 3 人为也可以尽量避免, 主要核心为 3</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 心跳相关</span><br>session.timeout.<span class="hljs-keyword">ms</span> <span class="hljs-title">= 6s</span><br>heartbeat.interval.<span class="hljs-keyword">ms</span> <span class="hljs-title">= 2s</span><br><br><span class="hljs-comment"># 消费时间</span><br>max.poll.interval.ms<br></code></pre></td></tr></table></figure></blockquote><h2 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h2><blockquote><p>Kafka 能支撑 TB 级别数据, 在日志级别有两个原因: 顺序写和日志索引. 顺序写后续会讲</p><p>Kafka 在一个日志文件达到一定数据量 (1G) 之后, 会生成新的日志文件, 大数据情况下会有多个日志文件, 通过偏移量来确定到某行纪录时, 如果遍历所有的日志文件, 那效率自然是很差的. Kafka 在日志级别上抽出来一层日志索引, 来方便根据 offset 快速定位到是某个日志文件</p><p>每一个 partition 对应多个个 log 文件(最大 1G), 每一个 log 文件又对应一个 index 文件</p><p>通过 offset 查找 Message 流程:</p><ol><li>先根据 offset (例: 368773), 二分定位到最大 小于等于该 offset 的 index 文件(368769.index)</li><li>通过二分(368773 - 368769 &#x3D; 4)定位到 index 文件 (368769.index) 中最大 小于等于该 offset 的 对于的 log 文件偏移量(3, 497)</li><li>通过定位到该文件的消息行(3, 497), 然后在往后一行一行匹配揭露(368773 830)</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4c9xnbjj307u05udg8-20230318165920446.jpg" alt="image"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4ccryuej30fc096my8-20230318165918338.jpg" alt="image"></p><h2 id="高性能-高吞吐"><a href="#高性能-高吞吐" class="headerlink" title="高性能, 高吞吐"></a>高性能, 高吞吐</h2><h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><blockquote><p>如果我们假设像标准 MQ 的 Queue, 为了保证一个消息只会被一个消费者消费, 那么我们第一想到的就是加锁. 对于发送者, 在多线程并且非顺序写环境下, 保证数据一致性, 我们同样也要加锁. 一旦考虑到加锁, 就会极大的影响性能. 我们再来看Kafka 的 Partition, Kafka 的消费模式和发送模式都是以 Partition 为分界. 也就是说对于一个 Topic 的并发量限制在于有多少个 Partition, 就能支撑多少的并发. 可以参考 Java 1.7 的 ConcurrentHashMap 的桶设计, 原理一样, 有多少桶, 支持多少的并发</p></blockquote><h3 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h3><blockquote><p>从图中可以看出来, 磁盘的顺序写的性能要比内存随机写的还要强. 磁盘顺序写和随机写的差距也是天壤之别</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4cl3xswj30wi0hkjud.jpg" alt="image-20200216190305830"></p><h3 id="批发送"><a href="#批发送" class="headerlink" title="批发送"></a>批发送</h3><blockquote><p>批处理是一种常用的用于提高I&#x2F;O性能的方式. 对Kafka而言, 批处理既减少了网络传输的Overhead, 又提高了写磁盘的效率. Kafka 0.82 之后是将多个消息合并之后再发送, 而并不是send一条就立马发送(之前支持)</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 批量发送的基本单位, 默认是16384Bytes, 即16kB</span><br>batch.size<br><br><span class="hljs-comment"># 延迟时间</span><br>linger.<span class="hljs-keyword">ms</span><br><br><span class="hljs-title"># 两者满足其一便发送</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><blockquote><p>数据压缩的一个基本原理是, 重复数据越多压缩效果越好. 因此将整个Batch的数据一起压缩能更大幅度减小数据量, 从而更大程度提高网络传输效率</p><p>Broker接收消息后，并不直接解压缩，而是直接将消息以压缩后的形式持久化到磁盘<br>Consumer 接受到压缩后的数据再解压缩</p><p>整体来讲: Producer 到 Broker, 副本复制, Broker 到 Consumer 的数据都是压缩后的数据, 保证高效率的传输</p></blockquote><h3 id="Page-Cache-amp-MMap"><a href="#Page-Cache-amp-MMap" class="headerlink" title="Page Cache &amp; MMap"></a>Page Cache &amp; MMap</h3><blockquote><p>利用 MMap 的读写文件也会依赖于 Page Cache, Page Cache 可以单独存在, 但是 MMap 会依赖于 Page Cache. MMap 是将文件映射到内存中, 底层来讲就是将 Page Cache 映射到用户空间, 从而使得用户空间可以直接操作文件</p></blockquote><h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><blockquote><p>内核会为每个文件单独维护一个page cache, 用户进程对于文件的大多数读写操作会直接作用到page cache上, 内核会选择在适当的时候将page cache中的内容写到磁盘上 (当然我们可以手工fsync控制回写), 这样可以大大减少磁盘的访问次数, 从而提高性能</p><p>至于刷盘时机: page cache中的数据会随着内核中flusher线程的调度以及对sync()&#x2F;fsync()的调用写回到磁盘, 同样也可以通过手动调用写磁盘</p></blockquote><h4 id="MMap-Memory-Mapped-Files-内存映射文件"><a href="#MMap-Memory-Mapped-Files-内存映射文件" class="headerlink" title="MMap (Memory Mapped Files, 内存映射文件)"></a>MMap (Memory Mapped Files, 内存映射文件)</h4><blockquote><p>MMap 是将一个文件或者其它对象映射进内存. Java 支持的零拷贝参考MappedByteBuffer</p></blockquote><p>正常的写流程:</p><blockquote><ol><li>JVM向OS发出read()系统调用, 触发上下文切换, 从用户态切换到内核态</li><li>从外部存储 (如硬盘)读取文件内容通过直接内存访问(DMA)存入内核地址空间的缓冲区</li><li>将数据从内核缓冲区拷贝到用户空间缓冲区, read()系统调用返回, 并从内核态切换回用户态</li><li>JVM向OS发出write()系统调用, 触发上下文切换, 从用户态切换到内核态</li><li>将数据从用户缓冲区拷贝到内核中与目的地Socket关联的缓冲区</li><li>数据最终经由Socket通过DMA传送到硬件(如网卡)缓冲区, write()系统调用返回, 并从内核态切换回用户态</li></ol><p>读取: 用户态切换到内核态, 在内核空间将文件读取到缓冲区, 再从内核区拷贝到用户缓冲区, 最后切换回用户态<br>写入: 用户态切换到内核态, 将数据从用户缓冲区拷贝到内核缓冲区, 再由DMA发送到硬件缓冲区, 最后切换回用户态</p><p>我们发现, 其实用户空间和内核空间的切换一共四次, 文件拷贝四次. 如果有一种方式文件</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4cpc2r3j30pm0oggmv-20230318165912617.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4csjdwgj30f409z759.jpg" alt="img"></p><p>mmap 的写流程</p><blockquote><ol><li>JVM向OS发出sendfile()系统调用</li><li>从外部存储 (如硬盘)读取文件内容通过直接内存访问(DMA)存入内核地址空间的缓冲区</li><li>数据最终经由Socket通过DMA传送到硬件(如网卡)缓冲区, write()系统调用返回, 并从内核态切换回用户态</li></ol><p>通过零拷贝, 我们减少了两次用户空间和内核空间的拷贝和一次内核空间和 Socket 缓冲区的拷贝, 总共节省三次拷贝, 并且没有用户态和内核态的转换</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4cwgimrj30ni0l4ab2.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4czqzqrj30n50co0u0.jpg" alt="img"></p><h4 id="Kafka-的运用"><a href="#Kafka-的运用" class="headerlink" title="Kafka 的运用"></a>Kafka 的运用</h4><blockquote><p>Kafka 写数据的时候, 会直接写到 Page Cache 中, 消费者拉数据时也会经过 Page Cache. 如果 Kafka 的写速率和消费速率差不多, 那么整个生产和消费过程是不会经过磁盘 IO. 全部都是内存操作. 对于 Page Cache 没有刷盘导致的数据丢失, 如果发送方配置消息至少有一个副本接受, 那么也只会有已一次同步刷盘</p><p>Kafka为什么不自己管理缓存, 而非要用page cache?</p><ol><li><p>JVM中一切皆对象, 数据的对象存储会带来所谓 object overhead 浪费空间</p></li><li><p>如果由JVM来管理缓存, 会受到GC的影响, 并且过大的堆也会拖累GC的效率, 降低吞吐量</p></li><li><p>一旦程序崩溃, 自己管理的缓存数据会全部丢失</p></li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4d3t3p7j30wu0imt9k.jpg" alt="img"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://image.baidu.com/search/down?url=http://mp.weixin.qq.com/s/WSdebVgIpvJ_c4DpFYqO4w">图解：Kafka 水印备份机制</a></p><p><a href="http://www.jasongj.com/tags/Kafka/">技术实践: Kafka</a></p><p><a href="https://image.baidu.com/search/down?url=http://www.cnblogs.com/yoke/p/11405397.html">Kafka Rebalance机制分析</a><a href="https://image.baidu.com/search/down?url=http://www.cnblogs.com/yoke/p/11405397.html">https://image.baidu.com/search/down?url=http://www.cnblogs.com/yoke/p/11405397.html</a>)</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 知识汇总</title>
    <link href="/2020/02/15/Redis%20%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2020/02/15/Redis%20%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p> Redis 是一款基于内存的数据库, 即 NoSQL. 采用单线程模型, 但是能10w 的并发. 底层使用 IO 多路复用模型(Java 中的 NIO, 即在进行 IO 是, 线程不阻塞可以处理其他事). </p><p> 常用的数据结构: String, List(可用作队列), Set, ZSet(sorted set有序集合), Hash</p><p> 持久化两种方式: RDB(快照) 和 AOF(日志追加)</p><p> 过期策略: 惰性删除 &#x2F; 定时删除 &#x2F; 定期删除</p><p> 内存淘汰: 八种淘汰方式</p><p> 分布式锁: 单节点 setnx ex, 集群基于 Red Lock实现 (开源框架 Redisson)</p><p> 集群方式: 主从, Sentinel 和 Redis Cluster</p><p> Keys 和 Scan: 都用用来获取匹配的元素</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">struct RedisObject &#123;<br>    <span class="hljs-built_in">int</span>4 type; <span class="hljs-comment">// 4bits</span><br>    <span class="hljs-built_in">int</span>4 encoding; <span class="hljs-comment">// 4bits</span><br>    <span class="hljs-built_in">int</span>24 lru; <span class="hljs-comment">// 24bits</span><br>    <span class="hljs-built_in">int32</span> <span class="hljs-built_in">ref</span>count; <span class="hljs-comment">// 4bytes</span><br>    <span class="hljs-built_in">void</span> *ptr; <span class="hljs-comment">// 8bytes，64-bit system</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><h3 id="String-sds"><a href="#String-sds" class="headerlink" title="String(sds)"></a>String(sds)</h3><blockquote><p>String 底层结构叫做 SDS(Simple Dynamic String). 最大支持 512M 长度, 在长度小于 44 时, 采用emb形式保存(连续空间), 当大于 44 是采用raw形式(不连续), 为什么是 44, 因为分配空间是 2 ^ n 字节来分配, 当内存分配 64 字节时, 去掉RedisObject, 和尾部的\0, 总共可使用 44 长度</p><p>扩容: 小于 1M 时, 采用加倍策略, 大于 1M 时, 每次扩容只会分配 1M</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">struct SDS&lt;T&gt; &#123;<br>  T capacity; <span class="hljs-regexp">//</span> 数组容量<br>  T len; <span class="hljs-regexp">//</span> 数组长度<br>  byte flags; <span class="hljs-regexp">//</span> 特殊标识位，不理睬它<br>  byte[] content; <span class="hljs-regexp">//</span> 数组内容<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hash-dict"><a href="#Hash-dict" class="headerlink" title="Hash(dict)"></a>Hash(dict)</h3><blockquote><p>Redis 中的 Hash 和 Java 1.7 的 Hash 结构一样, 都是数组 + 链表</p><p>Set 和 ZSet 的底层也是 Hash, 只不过 value 为 null</p><p>Hash的内部结构有两个 HashTable, 通常是只会有一个有值. 由于采用正常的扩容方式的时间复杂度为 O(n), 因此 Redis 的 Hash 采用渐进式扩容. 当需要扩容时会在执行命令时扩容一部分, 也会有定时任务对需要扩容的 Hash 进行扩容, 每次扩容一部分, 当扩容结束时, 就删除旧的 HashTable</p><p>扩容条件: 当 hash 的个数等于第一位数组的长度是就触发扩容, 扩容的新数组为原来的 2 倍. 如果扩容时刚好赶上 bgsave, 为了减少页分离(bgsave 采用fork 线程 + copy on write), 会尽量不扩容, 如果 hash 的个数已经达到一维数组的五倍, 则会强制扩容</p><p>缩容条件: 如果 hash 的个数小于一维数组的 10%, 则会触发缩容, 并且不会考虑 bgsave</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 一维数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span> &#123;<br>    dictEntry** table; <span class="hljs-comment">// 二维</span><br>    <span class="hljs-type">long</span> size; <span class="hljs-comment">// 第一维数组的长度</span><br>    <span class="hljs-type">long</span> used; <span class="hljs-comment">// hash 表中的元素个数</span><br>    ...<br>&#125;<br><span class="hljs-comment">// 链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> &#123;<br>    <span class="hljs-type">void</span>* key;<br>    <span class="hljs-type">void</span>* val;<br>    dictEntry* next; <span class="hljs-comment">// 链接下一个 entry</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="压缩链表-ziplist"><a href="#压缩链表-ziplist" class="headerlink" title="压缩链表(ziplist)"></a>压缩链表(ziplist)</h3><blockquote><p>Redis 为了节约内存空间使用，list, zset 和 hash 容器对象在元素个数较少的时候，采用压缩列表 (ziplist) 进行存储。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙. 增加 zltail_offset 便于定位到最后一个元素实现双向遍历</p><p>如果元素小于 254 字节, 则 prevlen 用 1 字节保存, 否则使用 5 字节保存. 也就是由于如果该字节修改前小于 254 字节, 修改后大于 254 字节, 就会导致连锁更新</p><p>优点: 节省内存<br>缺点: 连锁更新可能会导致内存拷贝, 效率低</p><p>hash-max-ziplist-entries 512 当 hash 的键值对数量小于 512 时使用压缩列表, 否则使用字典<br>hash-max-ziplist-value 64 当 hash 的键和值的长度小于 64 时使用压缩列表, 否则使用字典<br>list-max-ziplist-entries 512 当 list 的数量小于 512 时使用压缩列表, 否则使用快速列表<br>list-max-ziplist-value 64 当 list 的值小于 64 时使用压缩列表, 否则使用快速列表</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">struct</span> ziplist&lt;T&gt; &#123;<br>    <span class="hljs-type">int32</span> zlbytes; <span class="hljs-comment">// 整个压缩列表占用字节数</span><br>    <span class="hljs-type">int32</span> zltail_offset; <span class="hljs-comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span><br>    <span class="hljs-type">int16</span> zllength; <span class="hljs-comment">// 元素个数</span><br>    T[] entries; <span class="hljs-comment">// 元素内容列表，挨个挨个紧凑存储</span><br>    <span class="hljs-type">int8</span> zlend; <span class="hljs-comment">// 标志压缩列表的结束，值恒为 0xFF</span><br>&#125;<br><span class="hljs-keyword">struct</span> entry &#123;<br>    <span class="hljs-type">int</span>&lt;<span class="hljs-keyword">var</span>&gt; prevlen; <span class="hljs-comment">// 前一个 entry 的字节长度 只能为 1 字节或 5 字节</span><br>    <span class="hljs-type">int</span>&lt;<span class="hljs-keyword">var</span>&gt; encoding; <span class="hljs-comment">// 元素类型编码</span><br>    optional <span class="hljs-type">byte</span>[] content; <span class="hljs-comment">// 元素内容</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速列表-quicklist"><a href="#快速列表-quicklist" class="headerlink" title="快速列表(quicklist)"></a>快速列表(quicklist)</h3><blockquote><p>快速列表为 list 的实现, 3.2 之前的版本为 linkedlist. 为什么通过 quicklist 替换掉是因为 linkedlist的 prev 和 next要占用 16 字节, 并且每个节点的内存都是单独分配，会加剧内存的碎片化, 影响内存管理效率.</p><p>list-max-ziplist-size -2 每个快速列表的节点的压缩列表长度</p><p>-1 每个quicklistNode节点的ziplist字节大小不能超过4kb。（建议）<br>-2 每个quicklistNode节点的ziplist字节大小不能超过8kb。（默认配置）<br>-3 每个quicklistNode节点的ziplist字节大小不能超过16kb。（一般不建议）<br>-4 每个quicklistNode节点的ziplist字节大小不能超过32kb。（不建议）<br>-5 每个quicklistNode节点的ziplist字节大小不能超过64kb。（正常工作量不建议）</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ziplist</span> &#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ziplist_compressed</span> &#123;<br>    int32 size;<br>    <span class="hljs-type">byte</span>[] compressed_data;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> &#123;<br>    quicklistNode* prev;<br>    quicklistNode* next;<br>    ziplist* zl; <span class="hljs-comment">// 指向压缩列表</span><br>    int32 size; <span class="hljs-comment">// ziplist 的字节总数</span><br>    int16 count; <span class="hljs-comment">// ziplist 中的元素数量</span><br>    int2 encoding; <span class="hljs-comment">// 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span><br>    ...<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklist</span> &#123;<br>    quicklistNode* head;<br>    quicklistNode* tail;<br>    <span class="hljs-type">long</span> count; <span class="hljs-comment">// 元素总数</span><br>    <span class="hljs-type">int</span> nodes; <span class="hljs-comment">// ziplist 节点的个数</span><br>    <span class="hljs-type">int</span> compressDepth; <span class="hljs-comment">// LZF 算法压缩深度</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳跃列表"><a href="#跳跃列表" class="headerlink" title="跳跃列表"></a>跳跃列表</h3><blockquote><p>跳跃列表是 ZSet (Sorted Set) 的实现. Redis 的跳跃列表就是数据结构中的跳表, 在 Java 中的实现参考: ConcurrentSkipListSet 和 ConcurrentSkipListMap. 插入, 删除和修改的时间平均复杂度为O(log(N)), 最坏为 O(N). 之所以 Redis 使用跳表而不使用红黑树的原因是因为跳表实现更简单, 在插入删除是, 红黑树进行 rebalance 时需要影响整个树, 而跳表只影响局部数据</p><p>索引即为 ZSet 的score, 如果 score 相同, Redis 会使用 key 进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br>    <span class="hljs-comment">//节点对应成员的对象,一般是SDS</span><br>    robj *obj; <br>    <span class="hljs-comment">//分数,跳跃表的顺序按照分值进行排列</span><br>    <span class="hljs-type">double</span> score; <br>    <span class="hljs-comment">//存储后继节点的指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward; <br>    <span class="hljs-comment">// 层级</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-comment">// 存储前驱节点的指针</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward; <br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span; <br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 跳跃表的表头节点和表尾节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 跳跃表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 表中层数最大的节点层数</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki49t7i77j31as0qm78o-20230318170131586.jpg" alt="image-20201108220715910"></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><blockquote><p>Redis 的数据全部放在内存中 如果没有一种良好的持久化日志, 则会在宕机时丢失数据.</p><p>目前 Redis 通过两种方式实现持久化<br>RDB: 即时快照<br>AOF: 日志追加, 每执行一条命令, 就在日志后追加该条命令</p><p>默认 Redis 读取方式: 存在 AOF 加载 AOF, 如果不存在则判断是否存在 RDB 进行加载</p></blockquote><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><blockquote><p>Redis 在持久化是 fork 一个子线程, 通过 COW(Copy On Write)机制实现生成 RDB 文件保证持久化. 配置: save 60 1 表示 60s 内发生发生 1 次写入命令就触发生成 RDB</p><p>COW: 在多线程情况下, 拷贝一份用来自己写, 保证线程并发安全问题. 可参考 Java: CopyOnWriteArrayList<br>但是 Java 的实现是每当写的时候, 都会上锁拷贝出一份, 然后再拷贝的新的去执行写操作, 然后将拷贝的赋值给原始值. 但是在 Linux 不一样. Linux COW 在读时并不会 copy, 只有在写时, 对于写影响的页进行拷贝.</p><p>流程: fork 一个子线程, 子线程和父线程共享数据. 子线程遍历数据段来生成 RDB, 父线程当发生写操作是, 拷贝一根新的数据段, 在新的数据段进行写. 父线程的数据段为最新的数据. 子线程的数据不会受到影响, 也就是说子线程拿到的是当时的数据</p><p>优点: 服务宕机或重启恢复数据效率高<br>缺点: . 因为使用 COW机制, 因此如果在 fork 子线程之后, 父线程继续响应写事件, 但是此时宕机了, 就会导致数据丢失</p><p>操作命令: save(阻塞) &#x2F; bgsave(非阻塞)</p></blockquote><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><blockquote><p>AOF 就是一个日志把所有的操作命令记录下来(去掉读), 然后再宕机或者重启时将日志的命令重新执行一遍即可, 是持久化数据最为准确的一种方式. 配置: appendonly yes. appendfsync everysec 每秒同步一次</p><p>AOF 重写: 显而易见长期运行 AOF 的数据会越来越多, 如果重启则会需要非常长时间. 因此 Redis 提供 bgrewriteaof 命令优化掉update. delete等操作, 全部优化为 insert<br>原理: fork 一个子线程, 通过 COW 遍历数据, 生成对应的操作指令</p><p>刷盘: 因为 AOF 是需要磁盘 IO. 那么如果写一条命令就同步, 就会导致性能极其差.<br>解决方式: 利用 mmap 方式 (mmap 是内存映射文件的一种方式, 内核开辟一块空间映射到磁盘文件. 操作该文件直接操作内存, 依赖于 OS 来刷新内核空间的数据到磁盘)来处理 . 默认 Redis 是 1s 刷新一次</p><p>优点: 持久化效率最高, 并且数据不会丢失<br>缺点: 服务宕机或重启加载数据效率非常低</p><p>命令: bgrewriteaof</p></blockquote><h3 id="RDB-AOF-混合-4-0"><a href="#RDB-AOF-混合-4-0" class="headerlink" title="RDB + AOF 混合(4.0+)"></a>RDB + AOF 混合(4.0+)</h3><blockquote><p>定时生成 RDB, fork 子线程之后的操作指令会记录至 AOF 日志. 这样既能保证宕机或重启恢复效率高, 又能保证数据不丢失</p></blockquote><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><blockquote><p>对于一个 key 设置过期时间之后, Redis 会将对应的 key 放入到一个字典中</p><p>定时删除: 为该 key 创建一个定时器, 到时间之后自动删除<br>优点: 对内存友好, 不存在废弃数据占用内存<br>缺点: 对 CPU 极其不友好, 如果 key 比较多, 则会非常吃 CPU</p><p>定期删除: 每隔十秒对每个库进行一次随机扫描 20 个 key, 删除已过期的 key, 如果过期的比例低于 1&#x2F;4, 则重新扫描. 为了防止随机扫描时间过长, 默认不会超过 25ms<br>优点: 对 CPU 友好<br>缺点: 对内存不友好, 会导致垃圾数据没有被回收</p><p>惰性删除: 当访问该 key 时, 如果该 key 已过期, 则删除<br>优点: 简单<br>缺点: 对内存不友好</p><p>默认: 定期删除 + 惰性删除</p></blockquote><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><blockquote><p>当内存达到 maxmemory 配置时, 就会进行内存淘汰. Redis 提供 7 种淘汰机制</p><p>volatile-lru: 根据最近最少使用算法, 淘汰带有 有效期 属性的key及其数据<br>allkeys-lru: 同样根据最近最少使用算法, 但是淘汰范围的key是所有的key<br>volatile-lfu: 根据最不经常使用算法, 淘汰带有 有效期 属性的key及其数据 4.0 版本支持<br>allkeys-lfu，与第二种的淘汰范围相同, 不过使用的算法是最不经常使用算法 4.0 版本支持<br>volatile-random: 随机淘汰带有有效期属性的key及其数据<br>allkeys-random: 所有key都随机淘汰<br>volatile-ttl: 淘汰剩余寿命最短的key及其数据, ttl是 Time To Live的缩写<br>noeviction: 不再进行写操作, 只能读 默认配置</p></blockquote><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><blockquote><p>分布式锁其实个人觉得现在并没有一个非常完美的解决方案. 原因是因为对于锁的时间和业务时间无法完美的解决. 例: 如果业务时间超过了锁的时间, 如果继续锁, 那么这个分布式锁的时间设置就没有了意义, 如果不继续锁, 就可能会同时两个线程在操作相同的业务</p></blockquote><h3 id="setnx-ex"><a href="#setnx-ex" class="headerlink" title="setnx ex"></a>setnx ex</h3><blockquote><p>最简单的实现方式, 即没有该 key 是才去保存并且设置过期时间(2.8 之前没有该命令, 只能通过 lua实现). 而且仍然会有一个问题就是业务时间超时了如何处理. 这个时候新的线程持锁,  旧的线程执行完删除便会把新的线程的锁给删除. 所以相对安全的方式是: 设置锁时, 对 value 设置一个随机数, 这个随机数由本线程生成, 删除时校验该 value 是否为本线程的随机数. 这种方式也只是相对减少出错几率, 导致出错只会存在于超时的线程. 这种方式只能通过 Lua 脚本实现.</p><p>但是这种方式仅能使用在单节点的 Redis 中. 在集群的模式中, 因为主从同步延迟问题, 会出现一个线程明明已经上锁, 但是从库查不到又重新上锁的问题</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 上锁</span><br>tag = <span class="hljs-built_in">random</span>.nextint()  <span class="hljs-meta"># 随机数</span><br><span class="hljs-keyword">if</span> redis.set(key, tag, nx=<span class="hljs-literal">True</span>, ex=<span class="hljs-number">5</span>):<br>do_something()<br><br><span class="hljs-meta"># 锁释放 (lua 脚本)</span><br><span class="hljs-keyword">if</span> redis.<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> redis.<span class="hljs-built_in">call</span>(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure></blockquote><h3 id="Red-Lock-算法-具体实现参考-Redisson"><a href="#Red-Lock-算法-具体实现参考-Redisson" class="headerlink" title="Red Lock (算法, 具体实现参考 Redisson)"></a>Red Lock (算法, 具体实现参考 Redisson)</h3><blockquote><p>Red Lock 是目前最佳 Redis 集群实现的一种算法. 具体实现可参考 Redisson</p><ol><li><p>获取当前时间 (单位是毫秒)</p></li><li><p>轮流用相同的key和随机值在N个节点上请求锁, 在这一步里, 客户端在每个master上请求锁时, 会有一个和总的锁释放时间相比小的多的超时时间. 比如如果锁自动释放时间是10秒钟, 那每个节点锁请求的超时时间可能是5-50毫秒的范围, 这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间, 如果一个master节点不可用了, 我们应该尽快尝试下一个master节点</p></li><li><p>客户端计算第二步中获取锁所花的时间, 只有当客户端在大多数master节点上成功获取了锁 (在这里是3个), 而且总共消耗的时间不超过锁释放时间, 这个锁就认为是获取成功了</p></li><li><p>如果锁获取成功了, 那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间</p></li><li><p>如果锁获取失败了, 不管是因为获取成功的锁不超过一半 (N&#x2F;2+1)还是因为总消耗时间超过了锁释放时间, 客户端都会到每个master节点上释放锁, 即便是那些他认为没有获取成功的锁</p></li></ol></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote><p>Redis 的集群是满足 AP 理论, 选择最终一致性. Redis 支持主从同步和从从同步(减少主节点压力). </p><ol><li>设置主服务器的地址和端口</li><li>建立套接字连接</li><li>发送PING命令</li><li>身份验证</li><li>发送端口信息</li><li>同步</li><li>命令传播</li></ol></blockquote><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><blockquote><p>主节点内存中会有指令 buffer, 是一种环形结构, 如果 buffer 满了, 新的指令无论从库是否同步, 都会覆盖. 异步将 buffer 中的指令同步到从节点, 从节点反馈自己同步的偏移量. 如果从节点需要同步偏移量在 buffer 中已经不存在, 则需要执行快照同步</p><p>相关属性</p><ol><li>复制偏移量</li><li>复制缓冲区</li><li>运行ID</li></ol></blockquote><h3 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h3><blockquote><p>快照同步是一种比较耗时的同步方式. 快照同步会执行一次 bgsave, 然后异步把 rdb 发送给从节点, 从节点再 load. 因此主节点应该配置合适的 buffer size, 尽量避免快照同步</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki49394kej30hx0dngmt-20230318170131703.jpg" alt="img"></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="原生集群"><a href="#原生集群" class="headerlink" title="原生集群"></a>原生集群</h3><blockquote><p>原生仅支持一主多从, slave of 即为该种方式. 这种方式的缺点就是主节点宕机, 只能人工手动主从切换, 而无法自动主动切换, 无法实现高可用</p></blockquote><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><blockquote><p>这种方式俗称哨兵模式. 该模式相当于是对 Redis 主从集群加了一层监控集群 监控集群如果检测到主节点不可用, 立即切换最优从节点为主节点</p><p>&#x2F;&#x2F; 主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性<br>min-slaves-to-write 1<br>&#x2F;&#x2F; 10s 没有收到从节点的反馈，就意味着从节点同步不正常<br>min-slaves-max-lag 10</p></blockquote><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><blockquote><p>上述的两种都是主节点保存全量数据的方式. 在应当当下大数据的情况下, 一旦网络抖动或宕机导致全量同步, 就会极其影响效率甚至陷入全量同步死循环. 因此在考虑高可用的情况下, 自然而然就少不了分片</p><p>分片的作用是将全量数据分散到各个节点, 各个节点再通过集群保证高可用. 每个集群只维护各自的局部数据</p></blockquote><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><blockquote><p>Redis Cluster 是一个多主多从的架构. 每一个主节点对应多个从节点. 当检测到主节点宕机时, 自动切换其从节点为主节点. 并且是去中心架构</p><p>Redis Cluster 采用虚拟槽分区，所有的key根据哈希函数映射到0~16383槽. 当收到一条指令后, 任何一主节点会计算该指令应保存的槽, 如果不是当前节点, 则会转发到对应的主节点进行处理</p><p>FailOver (故障转移): 分为主观下线和客观下线<br>主观下线: 集群中每个节点都会定期向其他节点发送ping消息, 接收节点回复pong消息作为响应. 如果在cluster-node-timeout时间内通信一直失败, 则发送节点会认为接收节点存在故障, 把接收节点标记为主观下线(pfail)状态<br>客观下线: 当某个节点判断另一个节点主观下线后, 相应的节点状态会跟随消息在集群内传播. 通过Gossip消息传播, 集群内节点不断收集到故障节点的下线报告. 当半数以上持有槽的主节点都标记某个节点是主观下线时, 触发客观下线流程</p><ol><li>下线节点的集群投票选出新的主节点</li><li>选出的新主节点(从节点)取消复制变为主节点</li><li>执行clusterDelSlot操作撤销故障主节点负责的槽, 并执行clusterAddSlot把这些槽委派给自己</li><li>向集群广播自己的pong消息, 通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息</li></ol></blockquote><h2 id="Keys-和-Scan"><a href="#Keys-和-Scan" class="headerlink" title="Keys 和 Scan"></a>Keys 和 Scan</h2><blockquote><p>Keys 和 Scan 都是用来获取匹配的 key, 时间复杂度都是 O(n)</p><p>Keys: 阻塞主线程, 并且不支持分页, 对大数据量效率极低又因为 Redis 是单线程会阻塞主线程. 因此线上统一禁止使用</p><p>Scan: 支持分页, 但是返回的数据可能会重复. 通过游标分布进行, 不会阻塞线程 (设计很复杂). 遍历顺序非常特别, 它不是从第一维数组的第 0 位一直遍历到末尾, 而是采用了高位进位加法来遍历</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从根儿上理解 MySQL - 索引总结</title>
    <link href="/2020/01/30/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/30/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>上一篇我们已经知道了 Innodb 的页的数据结构和组成. 可以简介为下图所示</p><p>根据主键查询是在 Page Directory中进行二分搜索确定该数据所在的槽, 然后通过该槽偏移量确定页, 往后遍历查找数据</p><p>但是这是主键查询, 索引的原理也相同</p><p>ps: 基础直接跳过</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42ifh2zj31om0iu41w.jpg" alt="image-20200130141938214"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>在之前我们了解的主键查询是通过主键进行排序. 那么我们索引是利用我们的索引字段充当主键</p><p>下面其实就是主键索引, 又称聚簇索引, 橙色为主键, 绿色为对应的页<br>在非叶子节点的 record_type 都为 1 (表示为目录), 叶子节点的record_type 为 0 (表示为数据节点)</p><p>我们回顾一下一个页为 16KB, 假设一个页可以存放100 条记录(实际大部分场景远大于 100 条, 如果按照 100 条来算, 可以理解为每条数据 163 字节)</p><p>一层节点 100 ^ 1 条数据<br>两层节点 100 ^ 2 &#x3D; 10000 条数据<br>三层节点 100 ^ 3 &#x3D; 1000000 条数据<br>四层节点 100 ^ 4 &#x3D; 100000000 条数据</p></blockquote><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42l5bqlj31k00u00x3.jpg" alt="image-20200130142726854"></p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42oci7bj31kz0u0n1i.jpg" alt="image-20200130143518159"></p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42r550hj31k00u0td5.jpg" alt="image-20200130143720555"></p><blockquote><p>聚簇索引和非聚簇索引的区别就是, 聚簇索引的叶子节点保存所有数据, 非聚簇索引保存的是索引字段和主键(回表查询全量数据)</p><p>普通索引和联合索引的区别就是, 普通索引的用户数据只保存索引字段和页节点, 联合索引的用户数据为多个索引字段和页节点</p><p>联合索引中的字段值依次排序</p></blockquote><h4 id="页分裂情况"><a href="#页分裂情况" class="headerlink" title="页分裂情况"></a>页分裂情况</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42vetmhj30tk0v6mz5.jpg" alt="image-20200130144035751"></p><blockquote><p>考虑在上述情况下, 如果在插入相同 1 的数据是应该放在页 4 还是页 5 ?虽然是可以推到出放在页 5, 但是为了更加优化, 我们在非叶子节点中还是放入当前数据指向页的最小主键, 这样我们能更加清晰的知道是放在页 5, 如下图</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki42ymlatj30to0uognk.jpg" alt="image-20200130144529959"></p><blockquote><p>另外, 我们之前已经说过, 一个页最少要放入两条数据<br>原因: 如果每个页只能可以存放两条数据, 在查询效率上, 每次能筛选掉一半的数据. 如果允许存放一条数据, 那么相当于要全部遍历</p></blockquote><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><blockquote><p>覆盖索引并不是一种索引. 只是一种优化手段</p><p>如果一次查询所需要返回的字段在该索引中能够满足, 那么就不需要回表, 直接返回. 该方式即为覆盖索引(因为正常查询所有数据, 是需要通过非聚簇索引查到主键, 再回表查询聚簇索引获取全量数据)</p></blockquote><h2 id="如果确定索引列"><a href="#如果确定索引列" class="headerlink" title="如果确定索引列"></a>如果确定索引列</h2><blockquote><p>选择基数大的列 (可以理解为去重后的数量)</p><p>举例:</p><p>如果是性别列, 只有三个值: 男, 女, 第三性别. 那么基数即为 3</p><p>如果是时间秒值, 那么一天会有 86400. 那么基数即为 86400</p><p>选择性别列, 可能根据索引确定后, 依然有大量数据, 但是根据时间秒值, 能筛选掉大量的数据</p><p>同样. 如果 MySQL 优化器发现该索引筛选后的数据依然很大, 那么会选择走全表扫描</p><p>索引类型尽可能小<br>一个页的大小为 16KB, 如果类型尽可能小, 那么一个页存放的数据就会更多, 相同的索引数据层数就会更少, 占用空间也小</p></blockquote><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><blockquote><p>因为比较基础, 就直接总结</p><ol><li><code>B+</code>树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li><li><code>B+</code>树索引适用于下边这些情况：<ul><li>全值匹配</li><li>匹配左边的列</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul></li><li>在使用索引时需要注意下边这些事项：<ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul></li></ol></blockquote><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote><p>利用主键或唯一索引的等值匹配, 结果只会是一个值</p><p>IS NULL 并不是 const</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki432wfzcj31510u0wh1.jpg" alt="image-20200204145937352"></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>利用索引的等值匹配, 结果可能为多个值 (因为一个 key 可能对应多个 value)</p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki43643icj311q0u0go6.jpg" alt="image-20200204150348819"></p><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><blockquote><p> 上述再加上 null 的判断</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki439d0lej31220u0tbm.jpg" alt="image-20200204150602466"></p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><blockquote><p>范围查询</p><p>SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;&#x3D; 38 AND key2 &lt;&#x3D; 79);</p></blockquote><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><blockquote><p>SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 &#x3D; ‘abc’;</p><p>key_part2 没有索引, 但是可以通过遍历 key_part1_key_part2_key_part_3 来匹配结果, 这样的方式要比全表扫表成本小很多, 因此采用二级索引遍历的方式叫做 index</p></blockquote><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><blockquote><p>全表扫描</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>select * from table where a &#x3D; ‘’ or b &#x3D; ‘’<br>OR 只有 a 和 b 都有索引, 并且是等值查询时, 才会使用 UNION</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://image.baidu.com/search/down?url=http://juejin.im/book/6844733769996304392/section/6844733770046668814">MySQL 是怎样运行的：从根儿上理解 MySQL(B+树索引)</a></p><p><a href="https://image.baidu.com/search/down?url=http://juejin.im/book/6844733769996304392/section/6844733770046636045">MySQL 是怎样运行的：从根儿上理解 MySQL(B+树索引的使用)</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MySql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从根儿上理解 MySQL - 缓冲池 &amp; log</title>
    <link href="/2020/01/29/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E7%BC%93%E5%86%B2%E6%B1%A0%20&amp;%20log/"/>
    <url>/2020/01/29/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E7%BC%93%E5%86%B2%E6%B1%A0%20&amp;%20log/</url>
    
    <content type="html"><![CDATA[<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><blockquote><p>MySQL 在获取数据时, 是以页为单位. 每次读取一个页的数据放在内存中, 内存的哪里, 其实就是 Buffer Pool.<br>我们对页的所有处理都是在内存中处理, 至于刷盘时机, 在后续讲解中</p><p>Buffer Pool 是 MySQL 启动是申请的一块连续内存, 默认 128M, 最小为 5M</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki44uhzdxj31jq0isdhi-20230318165214024.jpg" alt="image-20200204182512548"></p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><blockquote><p>free 链表是把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中, 记录哪些页是可用的</p><p>缓存页的 key 为: 表空间号 + 页号</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki44xaguyj31e10u0n0f-20230318165251315.jpg" alt="image-20200204182629486"></p><h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><blockquote><p>如果修改了页, 此时内存中的页和磁盘的页就会不一致.</p><p>如果也发生修改就刷新到磁盘, 就会导致效率特别低下, 那么最好的方式就是一个链表管理发生修改的页, 在触发某种条件时刷新到磁盘. 这个链表就是 flush 链表</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki450nnyuj31f90u0tc6-20230318165254942.jpg" alt="image-20200204183017095"></p><h3 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h3><blockquote><p>我们 Buffer Pool 是有大小限制的. 但是每当我们读取页的时候, 就会把页加载进来. 一是很容易就撑满, 二是我们之所以设计 Buffer Pool 的原因就是更了更高效率的读取页, 充当缓存, 如果命中率很低, 那就没有太大的必要去维护 Buffer Pool. 那么 MySQL 是怎么提高命中率的和淘汰数据</p><p>淘汰数据是采用 LRU 列表</p><p>提高命中率是使用冷热数据, 冷数据为 young 区域, 热数据为 old 区域<br>那么对于全表扫描这种需要加载全部页的如果知道这些数据不应该放到缓存中呢?</p><p>在对某个处在<code>old</code>区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内(默认为 1s)，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部.</p><p>那么也就是说全表扫描拉取的也都是放在 young 区, 不会影响热数据, 因此并不会影响命中率</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki454ry9yj31ou0pitbv-20230318165314271.jpg" alt="image-20200204185448144"></p><h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><blockquote><ol><li>后台线程定时刷新</li><li>参考 redo log</li></ol></blockquote><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><blockquote><p>redo log 保证了 ACID 的 Durability (持久性)</p><p>MySQL 操作的基本单位是页, 如果只是一个很小的操作, 但是将一整个页的数据刷新到磁盘, 没必要. 如果通过记录修改内容日志, 刷新到磁盘, 效率会更高, 这个日志就是 redo log</p><p>页与页之间并不连续, 也就是随机写, 但是 redo log 是连续追加的, 性能很快</p><p>对于简单的操作, 可能只需要修改一个页中的一条数据<br>对于复杂的操作, 可能发生页分裂, 页拷贝和对索引的处理</p><p>mini transaction mtr: 对于复杂的操作, 以组的方式写入 redo log(一种特殊的类型, 尾部有校验)</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4581srkj31ii0e0ab2-20230318165311349.jpg" alt="image-20200204191546073"></p><h3 id="redo-log-页"><a href="#redo-log-页" class="headerlink" title="redo log 页"></a>redo log 页</h3><blockquote><p>redo log 页又称为 redo log block</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki45axw7qj31je0suq6e-20230318165308976.jpg" alt="image-20200204192255899"></p><h3 id="redo-log-缓冲区"><a href="#redo-log-缓冲区" class="headerlink" title="redo log 缓冲区"></a>redo log 缓冲区</h3><blockquote><p>InnoDB 为了解决磁盘慢引入了 Buffer Pool, 同样 redo log 也有缓冲区</p><p>先写入 redo log 缓冲区, 然后根据刷盘时机写入 redo log</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki45dtbukj31j80pgacy-20230318165306332.jpg" alt="image-20200204192440144"></p><h3 id="刷盘时机-1"><a href="#刷盘时机-1" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><blockquote><ol><li><code>log buffer</code>空间不足时</li><li>事务提交时</li><li>后台线程不停的刷 (平均一秒)</li><li>正常关闭服务器时</li><li>checkpoint</li></ol></blockquote><h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki45hi9l7j31hi0sm0v2-20230318165303303.jpg" alt="image-20200204192810689"></p><h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><blockquote><p>lsn: Log Sequeue Number, 记录已经写入的<code>redo</code>日志量. lsn 增加是以实际写入的日质量来增加</p><p>buf_free的位置为写入到 redo log buffer的偏移量(即为 lsn)</p><p>buf_next_to_write 的位置为实际已经刷新到磁盘的偏移量</p><p>如果两个值相同, 则说明所有的 redo log 都已经刷新到磁盘</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki45jtmlzj319g0mojt2-20230318165300701.jpg" alt="image-20200204193527217"></p><h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><blockquote><p>我们知道一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表</p></blockquote><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><blockquote><p>上面我们已经记录了, redo log buffer写到的位置, redo log 写到磁盘的位置. 同理 redo log 写到磁盘之前的位置已经没有用了, 但是我们不能删除, 为什么? 因为我们只是把 redo log 刷新到磁盘, 但是页还没有刷新, 需要等到 flush 链表该页刷新到磁盘之后, 才能删除, 换句话说就是被覆盖. 那么这个可以被覆盖的位置就是 checkpoint</p></blockquote><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><blockquote><p>综上所述, 我们系统崩溃时, checkpoint 之前的页都已经刷新到磁盘的, 对于 checkpoint 之后的虽然 redo log 刷新到磁盘, 但是页不一定刷新到磁盘. 如何判断是否刷新到磁盘</p><p>恢复的起点: 最新的 checkpoint </p><p>恢复的终点: log block header未被填满的 block</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MySql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从根儿上理解 MySQL - 页总结</title>
    <link href="/2020/01/28/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E9%A1%B5%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/28/%E4%BB%8E%E6%A0%B9%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3%20MySQL%20-%20%E9%A1%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h2><blockquote><p>由于 MySQL 的真实数据是存储在磁盘, 因此在读写数据是会涉及磁盘 IO, 为了更高效率的读取, MySQL 设计页结构, 每次交互以页为单位读取到内存. 页的大小一般为 16KB</p><p>一个数据页可以被大致划分为7个部分</p><p>File Header，表示页的一些通用信息，占固定的38字节。<br>Page Header，表示数据页专有的一些信息，占固定的56个字节。<br>Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。<br>User Records：真实存储我们插入的记录的部分，大小不固定。<br>Free Space：页中尚未使用的部分，大小不确定。<br>Page Directory：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。<br>File Trailer：用于检验页是否完整的部分，占用固定的8个字节。</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3zgsm1ej30u00yfq5z.jpg" alt="image-20200129175558772"></p><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3zjjr01j30vc0jsjth.jpg" alt="image-20200129175624645"></p><blockquote><p>上述的行格式即为 User Records的一部分</p><p>新生成的页并没有 User Records, 当插入数据时, 会从 Free Space 申请, 如果 Free Space 的空间全部被替换掉, 则说明该页满了, 需要申请新的页</p></blockquote><h4 id="File-Header-文件头部"><a href="#File-Header-文件头部" class="headerlink" title="File Header (文件头部)"></a>File Header (文件头部)</h4><blockquote><p>文件头部表主要关注点在于页号, 上一页的页号和下一页的页号. 构成了双向链表</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3znpswbj31au0q8acw.jpg" alt="image-20200130141415406"></p><h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory (页目录)"></a>Page Directory (页目录)</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3zrh8u9j31l00u00x4.jpg" alt="image-20200129180219930"></p><blockquote><p>从 select * from table wher id &#x3D; 1 讲起<br>比较笨的方式会从最小记录开始遍历往下找, 知道找到 next_record &#x3D; 0</p><p>MySQL 的优化点在于新增了一个目录, 利用二分查找优化</p><ol><li>通过二分法确定该记录所在的槽(实际是找到确定的槽, 遍历该槽的上一个槽或者当前槽)</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki40mdkthj31co0u0gqz.jpg" alt="image-20200129180437808"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的n_owned和next_record属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是<span class="hljs-attribute">low</span>=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：<br><br>计算中间槽的位置：(0+4)/<span class="hljs-attribute">2</span>=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置<span class="hljs-attribute">high</span>=2，low保持不变。<br><br>重新计算中间槽的位置：(0+2)/<span class="hljs-attribute">2</span>=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置<span class="hljs-attribute">low</span>=1，high保持不变。<br><br>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。<br><br>所以在一个数据页中查找指定主键值的记录的过程分为两步：<br><br>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。<br><br>通过记录的next_record属性遍历该槽所在的组中的各个记录。<br></code></pre></td></tr></table></figure><h2 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h2><blockquote><p>行格式主要分为四种类型Compact<code>、</code>Redundant<code>、</code>Dynamic<code>和</code>Compressed. 主要理解 Compact</p></blockquote><h3 id="Compact-行格式"><a href="#Compact-行格式" class="headerlink" title="Compact 行格式"></a>Compact 行格式</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3zv88vcj317g0du75j.jpg" alt="image-20200129145838600"></p><blockquote><p>行格式主要分为记录的额外信息, 记录的真实数据</p></blockquote><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><blockquote><p>变长字段长度列表存储的是变长类型的真实数据的占用字节数(逆序).</p><p>如果该表没有变长类型, 则无变长字段长度列表</p><p>变长字段长度列表只保存 NOT NULL列, 如果该列允许为 NULL, 则不会保存</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">举例: 字段 <span class="hljs-number">0</span> <span class="hljs-built_in">int</span> <span class="hljs-number">0</span>, 字段<span class="hljs-number">1</span> vachar(<span class="hljs-number">10</span>) <span class="hljs-literal">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">&#x27;A&#x27;</span>, 字段<span class="hljs-number">2</span> vachar(<span class="hljs-number">10</span>) <span class="hljs-literal">default</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">&#x27;B&#x27;</span>, 字段<span class="hljs-number">3</span> vachar(<span class="hljs-number">10</span>) <span class="hljs-literal">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">&#x27;AA&#x27;</span><br>变长字段长度列表: <span class="hljs-number">02</span> <span class="hljs-number">01</span><br>可通过 变长字段反推字段的长度<br></code></pre></td></tr></table></figure><h4 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h4><blockquote><p>NULL 值列表只统计哪些字段允许为 NULL的值状态(逆序)</p><p>如果该表没有允许 NULL 列, 则无 NULL 值列表</p><p>MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0</p><p>二进制位的值为1时，代表该列的值为NULL<br>二进制位的值为0时，代表该列的值不为NULL</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">举例: 字段 <span class="hljs-number">0</span> <span class="hljs-built_in">vachar</span>(<span class="hljs-number">10</span>) NOT <span class="hljs-literal">NULL</span> <span class="hljs-string">&#x27;A&#x27;</span>, 字段<span class="hljs-number">1</span> <span class="hljs-built_in">vachar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">default</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">&#x27;B&#x27;</span>, 字段<span class="hljs-number">2</span> <span class="hljs-built_in">vachar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">default</span> <span class="hljs-literal">NULL</span> <span class="hljs-literal">NULL</span>, 字段<span class="hljs-number">3</span> <span class="hljs-built_in">vachar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">default</span> <span class="hljs-literal">NULL</span> <span class="hljs-literal">NULL</span><br>逆序后: 字段<span class="hljs-number">3</span> - <span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> - <span class="hljs-number">1</span>, 字段<span class="hljs-number">1</span> - <span class="hljs-number">0</span><br><span class="hljs-literal">NULL</span> 值列表: <span class="hljs-number">00000110</span> <br>可通过 NOT <span class="hljs-literal">NULL</span> 字段反推哪些字段值为 <span class="hljs-literal">NULL</span>, 哪些字段值不为 <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h4 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h4><blockquote><p>这一部分牵扯的内容较多</p><p>大致可以看一下删除标识(删除是并非真正删除, 只是修改表示), 下一条记录位置(B+树特性)</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki400egxvj31t60diwfl.jpg" alt="image-20200129152146891"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki403ljuhj31440twtbe.jpg" alt="image-20200129152534179"></p><blockquote><p>除了这些详细信息, 还会有 MySQL 自动添加的隐藏列</p><p>实际上这几个列的真正名称其实是：DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR, 为了美观才写成了row_id、transaction_id和roll_pointer</p><p>row_id: 有主键使用主键, 没有主键有唯一键使用唯一键, 没有则自动生成</p><p>transaction_id: 事务 ID</p><p>roll_pointer: 回滚指针</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki406d6koj30wg0cewf4.jpg" alt="image-20200129152851500"></p><h4 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h4><blockquote><p>因为一个页占用 16KB, 16 * 1024 &#x3D; 16384 字节, 而 varchar 最多可以占用65535, 不包括隐藏列和记录头信息</p><p>但是在我们使用 varchar 时, 会设置变长字段长度列表和 NULL 值列表</p><p>对于 NOT NULL, 只能使用65533字节 (两个字节用来表示长度)<br>对于非 NOT NULL, 只用使用 65532 字节 (两个字节用来表示长度, 一个字节用来表示 NULL 标识)</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki40a7o14j31jk0u0td1.jpg" alt="image-20200129154058216"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">对于行溢出的情况, 真实的数据只用存储前<span class="hljs-number"> 768 </span>字节, 后面放的是溢出页地址<br></code></pre></td></tr></table></figure><h4 id="行溢出的节点"><a href="#行溢出的节点" class="headerlink" title="行溢出的节点"></a>行溢出的节点</h4><blockquote><p>综上所述, 我们知道在数据的占用字节数超过某个阈值就会发生行溢出, 那么行溢出的计算方式分析如下</p><p>ps: 截图来源于MySQL 是怎样运行的：从根儿上理解 MySQL(小孩子 4919)</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki40e1nh2j30u00xuag6.jpg" alt="image-20200129154804902"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h4><blockquote><p>这个属性标识该条记录是否已删除</p><p>如果 MySQL 设计删除一条则执行磁盘删除, 会导致磁盘IO增加, MySQL 为了优化, 使用一个标识表示该记录已被删除, 如果有新的记录来, 会覆盖该条记录<br>原理: 删除数据时, 标识该记录已删除, 并且放入垃圾链表, 新的记录插入时, 先从垃圾链表中替换</p><p>如果想要优化空间, 则执行 optimize table ‘name’ 即可</p></blockquote><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><blockquote><p>页与页之间通过 File Header 双向链表连接上一条记录和下一条记录</p><p>页内数据记录 通过 next_record 单向链表连接下一条记录</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://image.baidu.com/search/down?url=http://juejin.im/book/6844733769996304392/section/6844733770046636040">MySQL 是怎样运行的：从根儿上理解 MySQL(记录结构)</a></p><p><a href="https://image.baidu.com/search/down?url=http://juejin.im/book/6844733769996304392/section/6844733770046636046">MySQL 是怎样运行的：从根儿上理解 MySQL(数据页结构)</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MySql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>@MapperScan和@Mapper的坑</title>
    <link href="/2020/01/02/@MapperScan%E5%92%8C@Mapper%E7%9A%84%E5%9D%91/"/>
    <url>/2020/01/02/@MapperScan%E5%92%8C@Mapper%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今天和大佬一起解决个问题. @Autowired 注入的对象和预期不一致. 结果是因为 Mybatis 扫描的问题</p></blockquote><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h2><blockquote><p>此注解是 Mybatis 自动配置时, 默认扫描的注解类</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki4fh60jfj31at0czq4u.jpg" alt="image-20200102153553352"></p><h3 id="MybatisAutoConfiguration-AutoConfiguredMapperScannerRegistrar-registerBeanDefinitions"><a href="#MybatisAutoConfiguration-AutoConfiguredMapperScannerRegistrar-registerBeanDefinitions" class="headerlink" title="MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar#registerBeanDefinitions"></a>MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar#registerBeanDefinitions</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void register<span class="hljs-constructor">BeanDefinitions(AnnotationMetadata <span class="hljs-params">importingClassMetadata</span>, BeanDefinitionRegistry <span class="hljs-params">registry</span>)</span> &#123;<br><br>      logger.debug(<span class="hljs-string">&quot;Searching for mappers annotated with @Mapper&quot;</span>);<br><br>      ClassPathMapperScanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathMapperScanner(<span class="hljs-params">registry</span>)</span>;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (this.resourceLoader != null) &#123;<br>          scanner.set<span class="hljs-constructor">ResourceLoader(<span class="hljs-params">this</span>.<span class="hljs-params">resourceLoader</span>)</span>;<br>        &#125;<br><br>        List&lt;String&gt; packages = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AutoConfigurationPackages</span>.</span></span>get(this.beanFactory);<br>        <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>          <span class="hljs-keyword">for</span> (String pkg : packages) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Using auto-configuration base package &#x27;&#123;&#125;&#x27;&quot;</span>, pkg);<br>          &#125;<br>        &#125;<br><br><span class="hljs-comment">// 扫描 @Mapper 注解的类</span><br>        scanner.set<span class="hljs-constructor">AnnotationClass(Mapper.<span class="hljs-params">class</span>)</span>;<br>        scanner.register<span class="hljs-constructor">Filters()</span>;<br>        scanner.<span class="hljs-keyword">do</span><span class="hljs-constructor">Scan(StringUtils.<span class="hljs-params">toStringArray</span>(<span class="hljs-params">packages</span>)</span>);<br>      &#125; catch (IllegalStateException ex) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;</span>, ex);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h2><blockquote><p>设置扫描属性, 用于手动扫描, 可以设置扫描包, 扫描注解等信息</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gki4flax9xj30av043q36.jpg" alt="image-20200102153856893"></p><h3 id="MapperScannerRegistrar-registerBeanDefinitions"><a href="#MapperScannerRegistrar-registerBeanDefinitions" class="headerlink" title="MapperScannerRegistrar#registerBeanDefinitions"></a>MapperScannerRegistrar#registerBeanDefinitions</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void register<span class="hljs-constructor">BeanDefinitions(AnnotationMetadata <span class="hljs-params">importingClassMetadata</span>, BeanDefinitionRegistry <span class="hljs-params">registry</span>)</span> &#123;<br><br>    AnnotationAttributes annoAttrs = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotationAttributes</span>.</span></span>from<span class="hljs-constructor">Map(<span class="hljs-params">importingClassMetadata</span>.<span class="hljs-params">getAnnotationAttributes</span>(MapperScan.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>));<br>    ClassPathMapperScanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathMapperScanner(<span class="hljs-params">registry</span>)</span>;<br><br>    <span class="hljs-comment">// this check is needed in Spring 3.1</span><br>    <span class="hljs-keyword">if</span> (resourceLoader != null) &#123;<br>      scanner.set<span class="hljs-constructor">ResourceLoader(<span class="hljs-params">resourceLoader</span>)</span>;<br>    &#125;<br><br>    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.get<span class="hljs-constructor">Class(<span class="hljs-string">&quot;annotationClass&quot;</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Annotation</span>.</span></span><span class="hljs-keyword">class</span>.equals(annotationClass)) &#123;<br>      scanner.set<span class="hljs-constructor">AnnotationClass(<span class="hljs-params">annotationClass</span>)</span>;<br>    &#125;<br><br>    Class&lt;?&gt; markerInterface = annoAttrs.get<span class="hljs-constructor">Class(<span class="hljs-string">&quot;markerInterface&quot;</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">class</span>.equals(markerInterface)) &#123;<br>      scanner.set<span class="hljs-constructor">MarkerInterface(<span class="hljs-params">markerInterface</span>)</span>;<br>    &#125;<br><br>    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.get<span class="hljs-constructor">Class(<span class="hljs-string">&quot;nameGenerator&quot;</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanNameGenerator</span>.</span></span><span class="hljs-keyword">class</span>.equals(generatorClass)) &#123;<br>      scanner.set<span class="hljs-constructor">BeanNameGenerator(BeanUtils.<span class="hljs-params">instantiateClass</span>(<span class="hljs-params">generatorClass</span>)</span>);<br>    &#125;<br><br>    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.get<span class="hljs-constructor">Class(<span class="hljs-string">&quot;factoryBean&quot;</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapperFactoryBean</span>.</span></span><span class="hljs-keyword">class</span>.equals(mapperFactoryBeanClass)) &#123;<br>      scanner.set<span class="hljs-constructor">MapperFactoryBean(BeanUtils.<span class="hljs-params">instantiateClass</span>(<span class="hljs-params">mapperFactoryBeanClass</span>)</span>);<br>    &#125;<br><br>    scanner.set<span class="hljs-constructor">SqlSessionTemplateBeanName(<span class="hljs-params">annoAttrs</span>.<span class="hljs-params">getString</span>(<span class="hljs-string">&quot;sqlSessionTemplateRef&quot;</span>)</span>);<br>    scanner.set<span class="hljs-constructor">SqlSessionFactoryBeanName(<span class="hljs-params">annoAttrs</span>.<span class="hljs-params">getString</span>(<span class="hljs-string">&quot;sqlSessionFactoryRef&quot;</span>)</span>);<br><br>    List&lt;String&gt; basePackages = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">for</span> (String pkg : annoAttrs.get<span class="hljs-constructor">StringArray(<span class="hljs-string">&quot;value&quot;</span>)</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>has<span class="hljs-constructor">Text(<span class="hljs-params">pkg</span>)</span>) &#123;<br>        basePackages.add(pkg);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (String pkg : annoAttrs.get<span class="hljs-constructor">StringArray(<span class="hljs-string">&quot;basePackages&quot;</span>)</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>has<span class="hljs-constructor">Text(<span class="hljs-params">pkg</span>)</span>) &#123;<br>        basePackages.add(pkg);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : annoAttrs.get<span class="hljs-constructor">ClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)</span>) &#123;<br>      basePackages.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>get<span class="hljs-constructor">PackageName(<span class="hljs-params">clazz</span>)</span>);<br>    &#125;<br>    scanner.register<span class="hljs-constructor">Filters()</span>;<br>    scanner.<span class="hljs-keyword">do</span><span class="hljs-constructor">Scan(StringUtils.<span class="hljs-params">toStringArray</span>(<span class="hljs-params">basePackages</span>)</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过上述代码, 可以发现, @MapperScan 扫描的包下,统统都会被扫描(注入 MapperFactoryBean)</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>如果@MapperScan 默认扫描了全部, @SpringBoot 也扫描全部, 那么这里面的对象是MapperFactoryBean 还是真正的对象?</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gki4fp0kbtj314t03twgh.jpg" alt="image-20200102155310133"></p><p>一个为@Service 扫描, 一个为MybatisScan 扫描注入的 MapperFactoryBean</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p> 还是那句话, 不是人家设计的问题, 而是用的问题</p></blockquote><h3 id="为什么Mybatis-要根据扫描包内的路径-注入所有的类"><a href="#为什么Mybatis-要根据扫描包内的路径-注入所有的类" class="headerlink" title="为什么Mybatis 要根据扫描包内的路径, 注入所有的类"></a>为什么Mybatis 要根据扫描包内的路径, 注入所有的类</h3><blockquote><p>如果让你设计的话, 你怎么知道扫描的类是不是MyBatis 需要注入的类?</p><ol><li><p>特殊表示</p><p> 此种方式已经有@Mapper 来支撑, 并且无需扫描, 默认加载, 如果再使用@MapperScan, 实在是多此一举</p></li><li><p>只扫描 mapper 包</p><p> 问题所在就是这里, 如果只是使用方, 如果不多思考一下, 那么就很可能图懒就直接扫描个大包. 就会有问题</p></li></ol></blockquote><h3 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h3><blockquote><p>其实个人建议是能自动的尽量不要手动. 因为自动的在提供方已经准备的非常完善, 不会有问题, 但是恰恰手动操作的部分会有一些人为的遗漏或者考虑不周或者无法实现等问题, 而导致使用方不知道就完犊子</p><p>所以个人觉得最好的方式还是@Mapper, 自动就完了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务部分源码解析(四) - TransactionSynchronization注册</title>
    <link href="/2019/09/18/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E5%9B%9B)%20-%20TransactionSynchronization%E6%B3%A8%E5%86%8C/"/>
    <url>/2019/09/18/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E5%9B%9B)%20-%20TransactionSynchronization%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通过之前的文章我们已经知道对于一个事务执行多个业务,是通过实现TransactionSynchronization,当提交和回滚是回调完成.那么什么来注册TransactionSynchronization呢</p></blockquote><h2 id="TransactionSynchronizationManager"><a href="#TransactionSynchronizationManager" class="headerlink" title="TransactionSynchronizationManager"></a>TransactionSynchronizationManager</h2><blockquote><p>我们需要看一下registerSynchronization()方法的调用方,我们通过调用就可以知道第三方厂商实现调用的地方</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3tyo81nj30s80jcwi9.jpg" alt="image-20190926192218024"></p><blockquote><p>按照调用的引用关系. 目前我们的项目中有MyBatis, RabbitMQ, MongoDB, Redis, 和Spring jdbc有实现</p><p>接下来我们一步步看都是在何时注册</p></blockquote><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="SqlSessionUtils-registerSessionHolder"><a href="#SqlSessionUtils-registerSessionHolder" class="headerlink" title="SqlSessionUtils#registerSessionHolder()"></a>SqlSessionUtils#registerSessionHolder()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3u1uftoj30uy0gmgp2.jpg" alt="image-20190926192544701"></p><h3 id="SqlSessionSynchronization"><a href="#SqlSessionSynchronization" class="headerlink" title="SqlSessionSynchronization"></a>SqlSessionSynchronization</h3><blockquote><p>我们看一下具体实现TransactionSynchronization相关的commit和completion代码</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void before<span class="hljs-constructor">Commit(<span class="hljs-params">boolean</span> <span class="hljs-params">readOnly</span>)</span> &#123; <br>  <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TransactionSynchronizationManager</span>.</span></span>is<span class="hljs-constructor">ActualTransactionActive()</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>debug(<span class="hljs-string">&quot;Transaction synchronization committing SqlSession [&quot;</span> + this.holder.get<span class="hljs-constructor">SqlSession()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>      &#125;<br>      this.holder.get<span class="hljs-constructor">SqlSession()</span>.commit<span class="hljs-literal">()</span>;<br>    &#125; catch (PersistenceException p) &#123;<br>      <span class="hljs-keyword">if</span> (this.holder.get<span class="hljs-constructor">PersistenceExceptionTranslator()</span> != null) &#123;<br>        DataAccessException translated = this.holder<br>            .get<span class="hljs-constructor">PersistenceExceptionTranslator()</span><br>            .translate<span class="hljs-constructor">ExceptionIfPossible(<span class="hljs-params">p</span>)</span>;<br>        <span class="hljs-keyword">if</span> (translated != null) &#123;<br>          throw translated;<br>        &#125;<br>      &#125;<br>      throw p;<br>    &#125;<br>  &#125;<br>&#125;<br><br>public void before<span class="hljs-constructor">Completion()</span> &#123;<br>  <span class="hljs-comment">// Issue #18 Close SqlSession and deregister it now</span><br>  <span class="hljs-comment">// because afterCompletion may be called from a different thread</span><br>  <span class="hljs-keyword">if</span> (!this.holder.is<span class="hljs-constructor">Open()</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>debug(<span class="hljs-string">&quot;Transaction synchronization deregistering SqlSession [&quot;</span> + this.holder.get<span class="hljs-constructor">SqlSession()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TransactionSynchronizationManager</span>.</span></span>unbind<span class="hljs-constructor">Resource(<span class="hljs-params">sessionFactory</span>)</span>;<br>    this.holderActive = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>debug(<span class="hljs-string">&quot;Transaction synchronization closing SqlSession [&quot;</span> + this.holder.get<span class="hljs-constructor">SqlSession()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    this.holder.get<span class="hljs-constructor">SqlSession()</span>.close<span class="hljs-literal">()</span>;<br>  &#125;<br>&#125;<br><br>public void after<span class="hljs-constructor">Completion(<span class="hljs-params">int</span> <span class="hljs-params">status</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (this.holderActive) &#123;<br>    <span class="hljs-comment">// afterCompletion may have been called from a different thread</span><br>    <span class="hljs-comment">// so avoid failing if there is nothing in this one</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>debug(<span class="hljs-string">&quot;Transaction synchronization deregistering SqlSession [&quot;</span> + this.holder.get<span class="hljs-constructor">SqlSession()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TransactionSynchronizationManager</span>.</span></span>unbind<span class="hljs-constructor">ResourceIfPossible(<span class="hljs-params">sessionFactory</span>)</span>;<br>    this.holderActive = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LOGGER</span>.</span></span>debug(<span class="hljs-string">&quot;Transaction synchronization closing SqlSession [&quot;</span> + this.holder.get<span class="hljs-constructor">SqlSession()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br>    this.holder.get<span class="hljs-constructor">SqlSession()</span>.close<span class="hljs-literal">()</span>;<br>  &#125;<br>  this.holder.reset<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里有一个点: 我们发现MyBatis里只是实现了commit, holder的失效和resource的解绑. 并没有实现rollback.</p><p>个人觉得mybatis可能是觉得依赖于Connection的commit.因为本身在TransactionSynchronization的概念里,没有rollback只有commit和completion. 而Mybatis一定是依赖于ConnectionHolder,因此一定可以使用Connection的rollback.</p><p>但是我觉得我的理解是有问题的,因为MyBatis本身自己就实现了一套commit和rollback机制,当然底层还是使用Connection的commit和rollback.只不过是增加了一些缓存相关的处理.</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3u4o4xpj30yn0bt75y.jpg" alt="image-20190926194523630"></p><blockquote><p>通过方法名我们便可以看出,每当获取Session是,就会注册对应的TransactionSynchronization</p></blockquote><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="ConnectionFactoryUtils-bindResourceToTransaction"><a href="#ConnectionFactoryUtils-bindResourceToTransaction" class="headerlink" title="ConnectionFactoryUtils#bindResourceToTransaction()"></a>ConnectionFactoryUtils#bindResourceToTransaction()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3u74wg0j30qe07qjt1.jpg" alt="image-20190926194726213"></p><h3 id="RabbitResourceSynchronization"><a href="#RabbitResourceSynchronization" class="headerlink" title="RabbitResourceSynchronization"></a>RabbitResourceSynchronization</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void after<span class="hljs-constructor">Completion(<span class="hljs-params">int</span> <span class="hljs-params">status</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (status<span class="hljs-operator"> == </span>TransactionSynchronization.STATUS_COMMITTED) &#123;<br>this.resourceHolder.commit<span class="hljs-constructor">All()</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>this.resourceHolder.rollback<span class="hljs-constructor">All()</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (this.resourceHolder.is<span class="hljs-constructor">ReleaseAfterCompletion()</span>) &#123;<br>this.resourceHolder.set<span class="hljs-constructor">SynchronizedWithTransaction(<span class="hljs-params">false</span>)</span>;<br>&#125;<br>super.after<span class="hljs-constructor">Completion(<span class="hljs-params">status</span>)</span>;<br>&#125;<br><br>protected void release<span class="hljs-constructor">Resource(RabbitResourceHolder <span class="hljs-params">resourceHolder</span>, Object <span class="hljs-params">resourceKey</span>)</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionFactoryUtils</span>.</span></span>release<span class="hljs-constructor">Resources(<span class="hljs-params">resourceHolder</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Rabbit是已经实现了根据TransactionStatus来决定是commit还是rollback</p></blockquote><h3 id="ConnectionFactoryUtils-doGetTransactionalResourceHolder"><a href="#ConnectionFactoryUtils-doGetTransactionalResourceHolder" class="headerlink" title="ConnectionFactoryUtils#doGetTransactionalResourceHolder()"></a>ConnectionFactoryUtils#doGetTransactionalResourceHolder()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RabbitResourceHolder <span class="hljs-title function_">doGetTransactionalResourceHolder</span><span class="hljs-params">(ConnectionFactory connectionFactory,</span><br><span class="hljs-params">ResourceFactory resourceFactory)</span> &#123;<br><br>Assert.notNull(connectionFactory, <span class="hljs-string">&quot;ConnectionFactory must not be null&quot;</span>);<br>Assert.notNull(resourceFactory, <span class="hljs-string">&quot;ResourceFactory must not be null&quot;</span>);<br><br><span class="hljs-type">RabbitResourceHolder</span> <span class="hljs-variable">resourceHolder</span> <span class="hljs-operator">=</span> (RabbitResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory);<br><span class="hljs-keyword">if</span> (resourceHolder != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> resourceFactory.getChannel(resourceHolder);<br><span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> resourceHolder;<br>&#125;<br>&#125;<br><span class="hljs-type">RabbitResourceHolder</span> <span class="hljs-variable">resourceHolderToUse</span> <span class="hljs-operator">=</span> resourceHolder;<br><span class="hljs-keyword">if</span> (resourceHolderToUse == <span class="hljs-literal">null</span>) &#123;<br>resourceHolderToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitResourceHolder</span>();<br>&#125;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> resourceFactory.getConnection(resourceHolderToUse); <span class="hljs-comment">//NOSONAR</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are in a listener container, first see if there&#x27;s a channel registered</span><br><span class="hljs-comment"> * for this consumer and the consumer is using the same connection factory.</span><br><span class="hljs-comment"> */</span><br>channel = ConsumerChannelRegistry.getConsumerChannel(connectionFactory);<br><span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span> &amp;&amp; connection == <span class="hljs-literal">null</span>) &#123;<br>connection = resourceFactory.createConnection();<br><span class="hljs-keyword">if</span> (resourceHolder == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * While creating a connection, a connection listener might have created a</span><br><span class="hljs-comment"> * transactional channel and bound it to the transaction.</span><br><span class="hljs-comment"> */</span><br>resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager<br>.getResource(connectionFactory);<br><span class="hljs-keyword">if</span> (resourceHolder != <span class="hljs-literal">null</span>) &#123;<br>channel = resourceHolder.getChannel();<br>resourceHolderToUse = resourceHolder;<br>&#125;<br>&#125;<br>resourceHolderToUse.addConnection(connection);<br>&#125;<br><span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>channel = resourceFactory.createChannel(connection);<br>&#125;<br>resourceHolderToUse.addChannel(channel, connection);<br><span class="hljs-keyword">if</span> (resourceHolderToUse != resourceHolder) &#123;<br>bindResourceToTransaction(resourceHolderToUse, connectionFactory,<br>resourceFactory.isSynchedLocalTransactionAllowed());<br>&#125;<br><span class="hljs-keyword">return</span> resourceHolderToUse;<br><br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>RabbitUtils.closeConnection(connection);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmqpIOException</span>(ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>从方法名上看是获取TransactionResouceHolder.有点懵,我们继续往上看调用方</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3uc7peyj30ow0dyjtb.jpg" alt="image-20190926195649277"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ueyb10j30ud0rajvg.jpg" alt="image-20190926195743569"></p><blockquote><p>好了. 看到doExecute就知道是我们执行RabbitTemplate#convertAndSend()的具体实现</p></blockquote><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="MongoDbUtils-doGetDB"><a href="#MongoDbUtils-doGetDB" class="headerlink" title="MongoDbUtils#doGetDB()"></a>MongoDbUtils#doGetDB()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ujab9uj30q60f9mzd.jpg" alt="image-20190926195934239"></p><blockquote><p>可以理解为建立连接的时候就就直接注册</p></blockquote><h3 id="MongoSynchronization"><a href="#MongoSynchronization" class="headerlink" title="MongoSynchronization"></a>MongoSynchronization</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3um4tq9j30k803bmxf-20230318171105346.jpg" alt="image-20190926200013448"></p><blockquote><p>没什么好说的了,继承父类的绑定解绑Resource.没有自己的实现</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="RedisConnectionUtils-potentiallyRegisterTransactionSynchronisation"><a href="#RedisConnectionUtils-potentiallyRegisterTransactionSynchronisation" class="headerlink" title="RedisConnectionUtils#potentiallyRegisterTransactionSynchronisation()"></a>RedisConnectionUtils#potentiallyRegisterTransactionSynchronisation()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3uoy06sj30qz08owfh.jpg" alt="image-20190926200206610"></p><blockquote><p>可以看到是获取连接的时候进行注册</p></blockquote><h3 id="RedisTransactionSynchronizer"><a href="#RedisTransactionSynchronizer" class="headerlink" title="RedisTransactionSynchronizer"></a>RedisTransactionSynchronizer</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3us4dqfj30mw0ic407.jpg" alt="image-20190926200343949"></p><blockquote><p>虽然Redis的事务是基于乐观锁实现,很鸡肋,但是至少也是人家的一种态度.<br>我们看一下他的实现和Rabbit类似,都是继续status来commit或者rollback(discard表示取消事务)</p></blockquote><h3 id="RedisConnectionUtils-doGetConnection"><a href="#RedisConnectionUtils-doGetConnection" class="headerlink" title="RedisConnectionUtils#doGetConnection()"></a>RedisConnectionUtils#doGetConnection()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3uyf1j8j30rp0ko0vn-20230318171059125.jpg" alt="image-20190926200253579"></p><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><h3 id="DataSourceUtils-doGetConnection"><a href="#DataSourceUtils-doGetConnection" class="headerlink" title="DataSourceUtils#doGetConnection"></a>DataSourceUtils#doGetConnection</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3uvdnaij30ow0kwdj2.jpg" alt="image-20190926200808146"></p><h3 id="ConnectionSynchronization"><a href="#ConnectionSynchronization" class="headerlink" title="ConnectionSynchronization"></a>ConnectionSynchronization</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3v1xh50j30ju0id40y.jpg" alt="image-20190926200835955"></p><blockquote><p>这一部分发现Spring Jdbc主要是先除了解绑dataSource,还有一个作用是关闭连接</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>通过注册TransactionSynchronization实现类的代码,我们可以发现.这一部分其实是Spring提供开放性扩展的一个地方.首先Spring提供@Transactional注解,如果让自己来控制事务相关,假如一个事务中又有jdbc, 又有rabbit,又有redis,想一下自己控制的话需要写多少的冗余代码.但是spring提供的这个特性,和TransactionManager无关,在任何的TransactionManager中只要注册就可以执行.</p><p>例如: RabbitTemplate, RedisTemplate,并不依赖TransactionManager,只需要Connection就可自动和@Transactional集成.</p><p>现在我们串一下:</p><p>执行@Transactional方法,执行TransactionAspectSupport#invokeWithinTransaction(), 开启事务,执行方法(rabbitTemplate, redisTempalte等在方法中执行是会自动注册TransactionSynchronization至线程安全TransactionSynchronizationManager),异常设置线程共享变量rollbackOnly为true. 提交事务或回滚(TransactionSynchronizationManager#getSynchronizations(),然后遍历执行对应的方法)</p><p>好了, Spring事务相关你的代码已经写完.<br>接下来开始准备Dubbo的源码解析.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务部分源码解析(三) - TransactionSynchronization</title>
    <link href="/2019/09/17/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%20-%20TransactionSynchronization/"/>
    <url>/2019/09/17/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%20-%20TransactionSynchronization/</url>
    
    <content type="html"><![CDATA[<blockquote><p>接下来阅读触发时间相关源码</p></blockquote><h2 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h2><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ph6b05j30di08nab0-20230318170859099.jpg" alt="image-20190918180247521"></p><blockquote><p>可以看到触发事件有四个. commit前后,completion前后,<br>我们看下方代码比较直观</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processCommit</span>(<span class="hljs-title class_">DefaultTransactionStatus</span> status) throws <span class="hljs-title class_">TransactionException</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-built_in">boolean</span> beforeCompletionInvoked = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">prepareForCommit</span>(status);<br><span class="hljs-title function_">triggerBeforeCommit</span>(status);<br><span class="hljs-title function_">triggerBeforeCompletion</span>(status);<br>beforeCompletionInvoked = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">boolean</span> globalRollbackOnly = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (status.<span class="hljs-title function_">isNewTransaction</span>() || <span class="hljs-title function_">isFailEarlyOnGlobalRollbackOnly</span>()) &#123;<br>globalRollbackOnly = status.<span class="hljs-title function_">isGlobalRollbackOnly</span>();<br>&#125;<br><span class="hljs-keyword">if</span> (status.<span class="hljs-title function_">hasSavepoint</span>()) &#123;<br><span class="hljs-keyword">if</span> (status.<span class="hljs-title function_">isDebug</span>()) &#123;<br>logger.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Releasing transaction savepoint&quot;</span>);<br>&#125;<br>status.<span class="hljs-title function_">releaseHeldSavepoint</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status.<span class="hljs-title function_">isNewTransaction</span>()) &#123;<br><span class="hljs-keyword">if</span> (status.<span class="hljs-title function_">isDebug</span>()) &#123;<br>logger.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Initiating transaction commit&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doCommit</span>(status);<br>&#125;<br><span class="hljs-comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="hljs-comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span><br><span class="hljs-keyword">if</span> (globalRollbackOnly) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedRollbackException</span>(<br><span class="hljs-string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">UnexpectedRollbackException</span> ex) &#123;<br><span class="hljs-comment">// can only be caused by doCommit</span><br><span class="hljs-title function_">triggerAfterCompletion</span>(status, <span class="hljs-title class_">TransactionSynchronization</span>.<span class="hljs-property">STATUS_ROLLED_BACK</span>);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">TransactionException</span> ex) &#123;<br><span class="hljs-comment">// can only be caused by doCommit</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRollbackOnCommitFailure</span>()) &#123;<br><span class="hljs-title function_">doRollbackOnCommitException</span>(status, ex);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">triggerAfterCompletion</span>(status, <span class="hljs-title class_">TransactionSynchronization</span>.<span class="hljs-property">STATUS_UNKNOWN</span>);<br>&#125;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">RuntimeException</span> ex) &#123;<br><span class="hljs-keyword">if</span> (!beforeCompletionInvoked) &#123;<br><span class="hljs-title function_">triggerBeforeCompletion</span>(status);<br>&#125;<br><span class="hljs-title function_">doRollbackOnCommitException</span>(status, ex);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Error</span> err) &#123;<br><span class="hljs-keyword">if</span> (!beforeCompletionInvoked) &#123;<br><span class="hljs-title function_">triggerBeforeCompletion</span>(status);<br>&#125;<br><span class="hljs-title function_">doRollbackOnCommitException</span>(status, err);<br><span class="hljs-keyword">throw</span> err;<br>&#125;<br><br><span class="hljs-comment">// Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="hljs-comment">// propagated to callers but the transaction still considered as committed.</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">triggerAfterCommit</span>(status);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-title function_">triggerAfterCompletion</span>(status, <span class="hljs-title class_">TransactionSynchronization</span>.<span class="hljs-property">STATUS_COMMITTED</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-title function_">cleanupAfterCompletion</span>(status);<br>&#125;<br>&#125;<br><br><span class="hljs-string">``</span><span class="hljs-string">``</span><br><br>&gt; commit流程:<br>&gt;<br>&gt; <span class="hljs-number">1.</span> 预提交(扩展)<br>&gt; <span class="hljs-number">2.</span> 触发triggerBeforeCommit<br>&gt; <span class="hljs-number">3.</span> 触发triggerBeforeCompletion<br>&gt; <span class="hljs-number">4.</span> 提交<br>&gt; <span class="hljs-number">1.</span> 发生<span class="hljs-title class_">TransactionException</span>异常说明已经被标记rollback或者需要rollback,则执行triggerAfterCompletion处理,最终执行cleanupAfterCompletion<br>&gt; <span class="hljs-number">2.</span> 发生<span class="hljs-title class_">RuntimeException</span>或者<span class="hljs-title class_">Error</span>则会判断是否执行triggerBeforeCompletion,如果执行则执行triggerAfterCompletion,如果未执行则先triggerBeforeCompletion,最终执行cleanupAfterCompletion<br>&gt; <span class="hljs-number">5.</span> triggerAfterCommit<br>&gt; <span class="hljs-number">6.</span> triggerAfterCompletion<br>&gt; <span class="hljs-number">7.</span> cleanupAfterCompletion<br><br></code></pre></td></tr></table></figure><p>private void processRollback(DefaultTransactionStatus status) {<br>    try {<br>        try {<br>            triggerBeforeCompletion(status);<br>            if (status.hasSavepoint()) {<br>                if (status.isDebug()) {<br>                    logger.debug(“Rolling back transaction to savepoint”);<br>                }<br>                status.rollbackToHeldSavepoint();<br>            }<br>            else if (status.isNewTransaction()) {<br>                if (status.isDebug()) {<br>                    logger.debug(“Initiating transaction rollback”);<br>                }<br>                doRollback(status);<br>            }<br>            else if (status.hasTransaction()) {<br>                if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {<br>                    if (status.isDebug()) {<br>                        logger.debug(“Participating transaction failed - marking existing transaction as rollback-only”);<br>                    }<br>                    doSetRollbackOnly(status);<br>                }<br>                else {<br>                    if (status.isDebug()) {<br>                        logger.debug(“Participating transaction failed - letting transaction originator decide on rollback”);<br>                    }<br>                }<br>            }<br>            else {<br>                logger.debug(“Should roll back transaction but cannot - no transaction available”);<br>            }<br>        }<br>        catch (RuntimeException ex) {<br>            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);<br>            throw ex;<br>        }<br>        catch (Error err) {<br>            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);<br>            throw err;<br>        }<br>        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);<br>    }<br>    finally {<br>        cleanupAfterCompletion(status);<br>    }<br>}</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&gt; Rollback流程:<br>&gt;<br>&gt; <span class="hljs-number">1</span>. 触发triggerBeforeCompletion<br>&gt; <span class="hljs-number">2</span>. rollback(并不一定触发回滚,可能是设置回滚标识)<br>&gt; <span class="hljs-number">1</span>. 发生异常触发triggerAfterCompletion,并往上抛<br>&gt; <span class="hljs-number">3</span>. 触发triggerAfterCompletion<br>&gt; <span class="hljs-number">4</span>. cleanupAfterCompletion<br><br><span class="hljs-comment">### triggerBeforeCommit</span><br><br>![image-<span class="hljs-number">20190918181806849</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3pm79kkj30d705o74q-<span class="hljs-number">20230318170731895</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185623952</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3pon0fej30i904ft92-<span class="hljs-number">20230318170852690</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185926385</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3pqty7dj30p902uq37-<span class="hljs-number">20230318170732233</span>.jpg)<br><br><span class="hljs-comment">### triggerAfterCommit</span><br><br>![image-<span class="hljs-number">20190918181905137</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3ptnsmoj30d5057q39-<span class="hljs-number">20230318170848503</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185648103</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3py2hjyj30fc04dglw-<span class="hljs-number">20230318170732501</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185953086</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3q083q6j30hs01tgln-<span class="hljs-number">20230318170732880</span>.jpg)<br><br>![image-<span class="hljs-number">20190918190011335</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3q22tc4j30ka03ydg5-<span class="hljs-number">20230318170844018</span>.jpg)<br><br><span class="hljs-comment">### triggerBeforeCompletion</span><br><br>![image-<span class="hljs-number">20190918182207864</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3q4wob4j30df07u0tg-<span class="hljs-number">20230318170840701</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185712074</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3q8bv4rj30hx04cq3a-<span class="hljs-number">20230318170733218</span>.jpg)<br><br>![image-<span class="hljs-number">20190918190053220</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qc1pqij30pa05fjrv-<span class="hljs-number">20230318170733455</span>.jpg)<br><br><span class="hljs-comment">### triggerAfterCompletion</span><br><br>![image-<span class="hljs-number">20190918182444899</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qez5icj30k80adgnf-<span class="hljs-number">20230318170733727</span>.jpg)<br><br>![image-<span class="hljs-number">20190918185733079</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qj1bxdj30pz0arabr-<span class="hljs-number">20230318170833943</span>.jpg)<br><br>![image-<span class="hljs-number">20190918190737482</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qlv9fyj30pw06fmxu-<span class="hljs-number">20230318170831315</span>.jpg)<br><br></code></pre></td></tr></table></figure><p>到这里,我们的关注点就应该是TransactionSynchronization.至于TransactionSynchronizationUtils,只是通过TransactionSynchronizationManager..getSynchronizations()获取TransactionSynchronization,然后遍历调用而已</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">## TransactionSynchronization</span><br><br>![image-<span class="hljs-number">20190918191254211</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qomz6kj30hp0fv0ta-<span class="hljs-number">20230318170734199</span>.jpg)<br><br><span class="hljs-comment">### 子类</span><br><br>![image-<span class="hljs-number">20190918191314396</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qrh7x5j31cr0a978w-<span class="hljs-number">20230318170734333</span>.jpg)<br><br><span class="hljs-comment">### SqlSessionSynchronization(Mybatis)</span><br><br>![image-<span class="hljs-number">20190918221701492</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qturt4j30qi0jndig-<span class="hljs-number">20230318170734469</span>.jpg)<br><br><span class="hljs-comment">#### RabbitResourceSynchronization</span><br><br>![image-<span class="hljs-number">20190918191514543</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3qxllvzj30mo0i90ux-<span class="hljs-number">20230318170734629</span>.jpg)<br><br><span class="hljs-comment">### RedisTransactionSynchronizer</span><br><br>![image-<span class="hljs-number">20190918215145038</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Gallrax/</span>blog-image<span class="hljs-regexp">/master/u</span>Pic/<span class="hljs-number">0081</span>Kckwly1gki3r0evtrj30ni0pjq5g-<span class="hljs-number">20230318170823107</span>.jpg)<br><br>&gt; 仅举例表示对接实现<br>&gt;<br>&gt; 目前项目中使用RabbitMQ, 当RabbitTemplate.channelTransacted = true时,会绑定TransactionSynchronization在使用@Transactional的方法之后会走到此处,执行RabbitMQ的发送和回滚<br><br></code></pre></td></tr></table></figure><p>我们发现两个类是继承了ResourceHolderSynchronization</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><br>### ResourceHolderSynchronization<br><br>![image-20190918220026988](https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3rc2ttmj30hp0fvabc-20230318170815738.jpg)<br><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">相比<span class="hljs-title class_">TransactionSynchronization</span> 增加了红框的几个方法</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">核心的commit和completion已经做出抽象实现.具体又子类具体实现</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">看一下代码</span><br><br></code></pre></td></tr></table></figure><p>@Override<br>    public void suspend() {<br>        if (this.holderActive) {<br>            TransactionSynchronizationManager.unbindResource(this.resourceKey);<br>        }<br>    }</p><pre><code class="hljs">@Overridepublic void resume() &#123;    if (this.holderActive) &#123;        TransactionSynchronizationManager.bindResource(this.resourceKey, this.resourceHolder);    &#125;&#125;@Overridepublic void flush() &#123;    flushResource(this.resourceHolder);&#125;@Overridepublic void beforeCommit(boolean readOnly) &#123;&#125;@Overridepublic void beforeCompletion() &#123;    if (shouldUnbindAtCompletion()) &#123;        TransactionSynchronizationManager.unbindResource(this.resourceKey);        this.holderActive = false;        if (shouldReleaseBeforeCompletion()) &#123;            releaseResource(this.resourceHolder, this.resourceKey);        &#125;    &#125;&#125;@Overridepublic void afterCommit() &#123;    if (!shouldReleaseBeforeCompletion()) &#123;        processResourceAfterCommit(this.resourceHolder);    &#125;&#125;@Overridepublic void afterCompletion(int status) &#123;    if (shouldUnbindAtCompletion()) &#123;        boolean releaseNecessary = false;        if (this.holderActive) &#123;            // The thread-bound resource holder might not be available anymore,            // since afterCompletion might get called from a different thread.            this.holderActive = false;            TransactionSynchronizationManager.unbindResourceIfPossible(this.resourceKey);            this.resourceHolder.unbound();            releaseNecessary = true;        &#125;        else &#123;            releaseNecessary = shouldReleaseAfterCompletion(this.resourceHolder);        &#125;        if (releaseNecessary) &#123;            releaseResource(this.resourceHolder, this.resourceKey);        &#125;    &#125;    else &#123;        // Probably a pre-bound resource...        cleanupResource(this.resourceHolder, this.resourceKey, (status == STATUS_COMMITTED));    &#125;    this.resourceHolder.reset();&#125;/** * Return whether this holder should be unbound at completion * (or should rather be left bound to the thread after the transaction). * &lt;p&gt;The default implementation returns &#123;@code true&#125;. */protected boolean shouldUnbindAtCompletion() &#123;    return true;&#125;/** * Return whether this holder&#39;s resource should be released before * transaction completion (&#123;@code true&#125;) or rather after * transaction completion (&#123;@code false&#125;). * &lt;p&gt;Note that resources will only be released when they are * unbound from the thread (&#123;@link #shouldUnbindAtCompletion()&#125;). * &lt;p&gt;The default implementation returns &#123;@code true&#125;. * @see #releaseResource */protected boolean shouldReleaseBeforeCompletion() &#123;    return true;&#125;/** * Return whether this holder&#39;s resource should be released after * transaction completion (&#123;@code true&#125;). * &lt;p&gt;The default implementation returns &#123;@code !shouldReleaseBeforeCompletion()&#125;, * releasing after completion if no attempt was made before completion. * @see #releaseResource */protected boolean shouldReleaseAfterCompletion(H resourceHolder) &#123;    return !shouldReleaseBeforeCompletion();&#125;/** * Flush callback for the given resource holder. * @param resourceHolder the resource holder to flush */protected void flushResource(H resourceHolder) &#123;&#125;/** * After-commit callback for the given resource holder. * Only called when the resource hasn&#39;t been released yet * (&#123;@link #shouldReleaseBeforeCompletion()&#125;). * @param resourceHolder the resource holder to process */protected void processResourceAfterCommit(H resourceHolder) &#123;&#125;/** * Release the given resource (after it has been unbound from the thread). * @param resourceHolder the resource holder to process * @param resourceKey the key that the ResourceHolder was bound for */protected void releaseResource(H resourceHolder, K resourceKey) &#123;&#125;/** * Perform a cleanup on the given resource (which is left bound to the thread). * @param resourceHolder the resource holder to process * @param resourceKey the key that the ResourceHolder was bound for * @param committed whether the transaction has committed (&#123;@code true&#125;) * or rolled back (&#123;@code false&#125;) */protected void cleanupResource(H resourceHolder, K resourceKey, boolean committed) &#123;&#125;</code></pre><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">可能这里讲的比较乱.大概说一下这些用途吧</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">TransactionSynchronization</span>这个类更多扩展的用途是在于afterCompletion,对于像jdbc,rabbit,redis这些可以在执行结束后释放<span class="hljs-title class_">Transactional</span> resources</span><br><br></code></pre></td></tr></table></figure><p>我们再回头想一下,我们是从TransactionSynchronizationManager才找到TransactionSynchronization.为什么TransactionSynchronization会放在TransactionSynchronizationManager.TransactionSynchronizationManager的意义在于什么?我们看一下</p><pre><code class="hljs">## TransactionSynchronizationManager![image-20190918221920971](https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3r7w4xnj30pw0hvmzl.jpg)&gt; 方法大致如下&gt; 注册,解绑,绑定,获取,清空&gt; 我们看一下属性![image-20190918222051306](https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3r4ysyyj30lo0ah0uf-20230318170735964.jpg)&gt; 看到ThreadLocal,似乎知道了些什么&gt; 多个线程,每个线程又需要对应多个厂商的事务连接,并且每个事务连接朝生夕死,虽然spring容器支持多例,但是多例如何传递?需要怎么处理?&gt; 通过TransactionSynchronizationManager的ThreadLocal来在线程上下文传递.也许才是最解耦最优雅的方式## 总结&gt; AbstractPlatformTransactionManager提供抽象方法,子类具体实现(RabbitTransactionManager, DataSourceTransactionManager)&gt; TransactionSynchronization提供接口供第三方扩展注册,用于一个事务的多方处理(db, mq等, 实现如RabbitResourceSynchronization, RedisTransactionSynchronizer, SqlSessionSynchronization)&gt; 那么问题又来了AbstractPlatformTransactionManager的实现类在什么时候注册,是么时候获取?&gt; TransactionSynchronization的实现类在什么时候注册?什么时候绑定?什么时候获取?&gt; 写一篇讲解Spring定义抽象的实现类何时加载处理</code></pre>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务部分源码解析(二) - 事务管理器</title>
    <link href="/2019/09/16/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%20-%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2019/09/16/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%20-%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>按照上篇流程详解</p></blockquote><h3 id="获取方法的Transaction配置"><a href="#获取方法的Transaction配置" class="headerlink" title="获取方法的Transaction配置"></a>获取方法的Transaction配置</h3><blockquote><p> 按照上篇对于几个实体类的描述,可以发现注解@Transactional的属性的字段和TransactionDefinition大致比较相似,但又不完全一致.</p></blockquote><p>从@Transactional开始讲起</p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3m4fm1bj30f00ekdgq.jpg"></p><p>这个显然很常见,就是我们平时需要事务时用到的注解.可是spring如何去解析?我们看一下使用到这个注解的地方,排除掉在test和comment下的使用.</p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3m2gwpij30iv07jdgi.jpg"></p><p>进入方法</p><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3m0liy5j30v70nxwje.jpg"></p><p>TransactionAttribute正是上篇文章中TransactionDefinition的子类</p><p>返回的RuleBasedTransactionAttribute我们看一下他的继承图</p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3lypwk2j30k009cjry.jpg"></p><p>我们打开源码看一下RuleBasedTransactionAttribute和父类DefaultTransactionAttribute晚上寻找发现,事务常规的设置是继承DefaultTransactionDefinition来注入,rollback相关则实现TransactionAttribute.这就是我们上篇提到TransactionAttribute和TransactionDefinition责任的划分</p><p>我们网上追溯,调用方</p><blockquote><p>AnnotationTransactionAttributeSource.findTransactionAttribute()</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3lx84rnj30lf0gsmzx.jpg"></p><blockquote><p> AbstractFallbackTransactionAttributeSource.computeTransactionAttribute</p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3lwqa9rj30ml0m7n0n.jpg"></p><blockquote><p>AnnotationTransactionAttributeSource.getTransactionAttribute()</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3lt4fiyj30qk0kyjum.jpg"></p><blockquote><p>TransactionAspectSupport.invokeWithinTransaction</p></blockquote><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3lrq55zj30qj0fptb8.jpg"></p><blockquote><p>获取Transaction配置流程:根据方法和类确定唯一key,从缓存中获取.如果获取不到则通过TransactionAnnotationParser解析方法来获取事务属性.并放置缓存中</p></blockquote><h3 id="获取事务管理器-PlatformTransactionManager"><a href="#获取事务管理器-PlatformTransactionManager" class="headerlink" title="获取事务管理器(PlatformTransactionManager)"></a>获取事务管理器(PlatformTransactionManager)</h3><blockquote><p>接口定义方法(可以发现极其精简干净)</p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3lpdfbpj30f00ekdg9.jpg"></p><blockquote><p>抽象子类AbstractPlatformTransactionManager, 可以发现多了很多方法.但并没有实现,用于子类继承处理</p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3lnhva1j30mq0sun3d.jpg"></p><blockquote><p>子类</p></blockquote><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3llm0hfj312j04ign8.jpg"></p><blockquote><p>我们可以关注一下DataSourceTransactionManager和RabbitTransactionManager,是抽象类的一个实现.DataSourceTransactionManager的具体实现是通过Java提供的接口实现.而RabbitTransactionManager则是自己实现(毕竟已经属于定制了)</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">此处可以回顾TransactionAspectSupport<span class="hljs-selector-class">.invokeWithinTransaction</span>(), 开启事务后上下文通过TransactionInfo传递信息. 每当设计事务提交或回滚等相关,都是txInfo<span class="hljs-selector-class">.getTransactionManager</span>()<span class="hljs-selector-class">.commit</span>()/<span class="hljs-built_in">rollback</span>()<br></code></pre></td></tr></table></figure><h4 id="AbstractPlatformTransactionManager-rollback"><a href="#AbstractPlatformTransactionManager-rollback" class="headerlink" title="AbstractPlatformTransactionManager.rollback()"></a>AbstractPlatformTransactionManager.rollback()</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ljlt87j30qd04w3z5.jpg"></p><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3lhhoc5j30s90p4tcj.jpg"></p><p><img src="https://image.baidu.com/search/down?url=http://tva1.sinaimg.cn/large/0081Kckwly1gki3lfigu6j30i00480ta.jpg"></p><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3le0s5cj30pc05fwf6.jpg"></p><blockquote><p>大致说一下回滚流程.</p><ol><li>触发TransactionSynchronization完成前事件</li><li>事务具体实现的真正回滚</li><li>触发TransactionSynchronization完成后事件</li><li>标记完成,执行后续清理操作</li></ol></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">ps:</span> 如果一个方法需要执行多个事务如何处理<span class="hljs-string">?(</span>剧透一下<span class="hljs-symbol">:TransactionSynchronization</span>)<br></code></pre></td></tr></table></figure><h4 id="AbstractPlatformTransactionManager-commit"><a href="#AbstractPlatformTransactionManager-commit" class="headerlink" title="AbstractPlatformTransactionManager.commit()"></a>AbstractPlatformTransactionManager.commit()</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3lc5x3zj30qh0fzaco.jpg"></p><blockquote><p>从图中看出在某种情况会执行回滚操作.最开始看到这里的时候也迷过.后来在一次事务测试时,同一个事务,方法嵌套时,内部方法抛异常,但是外部方法捕获正常处理.一部分觉得内部回滚外部不回滚.实际结果是内外都会回滚和是否捕获并没有关系. 可以回顾一下processRollback()中的status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()判断</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span>ean globalRollbackOnParticipationFailure = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>默认为true,也就是说在非特意设置的情况下会执行doSetRollbackOnly(status);将rollbackOnly设置为true.在也就是说当内部内部方法发生异常之后会上下文TransactionStatus.rollbackOnly为true,执行的便是processRollback().这也就解释为什么内部方法捕获之后依旧会回滚的原因&#x2F;</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">ps: 本身在同一个事务,内部方法发生异常执行回滚,理应是整个事务回滚而不是部分回滚.以为捕获异常处理之后再提交这种思想本身就不对噢!!!<br></code></pre></td></tr></table></figure></blockquote><p>如果没有发生异常.则执行正常提交流程</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processCommit</span><span class="hljs-params">(DefaultTransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">boolean</span> beforeCompletionInvoked = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br>prepareForCommit(status);<br>triggerBeforeCommit(status);<br>triggerBeforeCompletion(status);<br>beforeCompletionInvoked = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">boolean</span> globalRollbackOnly = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">if</span> (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;<br>globalRollbackOnly = status.isGlobalRollbackOnly();<br>&#125;<br><span class="hljs-keyword">if</span> (status.hasSavepoint()) &#123;<br><span class="hljs-keyword">if</span> (status.isDebug()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Releasing transaction savepoint&quot;</span>);<br>&#125;<br>status.releaseHeldSavepoint();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status.isNewTransaction()) &#123;<br><span class="hljs-keyword">if</span> (status.isDebug()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Initiating transaction commit&quot;</span>);<br>&#125;<br>doCommit(status);<br>&#125;<br><span class="hljs-comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="hljs-comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span><br><span class="hljs-keyword">if</span> (globalRollbackOnly) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnexpectedRollbackException(<br><span class="hljs-string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (UnexpectedRollbackException ex) &#123;<br><span class="hljs-comment">// can only be caused by doCommit</span><br>triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (TransactionException ex) &#123;<br><span class="hljs-comment">// can only be caused by doCommit</span><br><span class="hljs-keyword">if</span> (isRollbackOnCommitFailure()) &#123;<br>doRollbackOnCommitException(status, ex);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);<br>&#125;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br><span class="hljs-keyword">if</span> (!beforeCompletionInvoked) &#123;<br>triggerBeforeCompletion(status);<br>&#125;<br>doRollbackOnCommitException(status, ex);<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (Error err) &#123;<br><span class="hljs-keyword">if</span> (!beforeCompletionInvoked) &#123;<br>triggerBeforeCompletion(status);<br>&#125;<br>doRollbackOnCommitException(status, err);<br><span class="hljs-keyword">throw</span> err;<br>&#125;<br><br><span class="hljs-comment">// Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="hljs-comment">// propagated to callers but the transaction still considered as committed.</span><br><span class="hljs-keyword">try</span> &#123;<br>triggerAfterCommit(status);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>cleanupAfterCompletion(status);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>执行流程</p><ol><li>执行预提交处理</li><li>触发提交前事件</li><li>触发完成事件</li><li>提交</li><li>触发提交事件</li><li>触发提交完成事件</li><li>清除状态</li></ol></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">个人理解的第一步是预留分布式事务接口. 而后续的触发时间则是扩展处理<span class="hljs-comment">(后续讲TransactionSynchronization会聊到)</span>,不过这个扩展处理划分的也太细了<br></code></pre></td></tr></table></figure><h4 id="AbstractPlatformTransactionManager-cleanupAfterCompletion"><a href="#AbstractPlatformTransactionManager-cleanupAfterCompletion" class="headerlink" title="AbstractPlatformTransactionManager.cleanupAfterCompletion()"></a>AbstractPlatformTransactionManager.cleanupAfterCompletion()</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3l8ef3xj30mh089gmu.jpg"></p><blockquote><p>其实这里也没什聊的,打开方法的源码基本能发现都是清除上下文状态.也代表事务的结束</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><ol><li>AbstractPlatformTransactionManager实现了核心的逻辑,每一个核心的逻辑的具体实现又留给各个厂商实现.这一部分挺像AbstractQueuedSynchronizer的.设计挺好的.扩展性好,具体的逻辑又帮你实现好.只需要继承定制实现自己非常简单的逻辑就好</li><li>事务嵌套情况通过线程上线文来处理</li><li>多事务通过触发事件处理(后续讲TransactionSynchronization会聊到),扩展性真的挺好</li></ol></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">下一篇讲触发事件处理.相关类TransactionSynchronizationManager, TransactionSynchronizationUtils, TransactionSynchronization<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务部分源码解析(一)</title>
    <link href="/2019/09/15/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <url>/2019/09/15/Spring%E4%BA%8B%E5%8A%A1%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>方便谈扩展,项目引用Jdbc和RabbitMQ<br>源码版本spring 4.3.x</p></blockquote><h2 id="从TransactionInterceptor开始"><a href="#从TransactionInterceptor开始" class="headerlink" title="从TransactionInterceptor开始"></a>从TransactionInterceptor开始</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3gse4nmj30yg0cvgnq.jpg" alt="image.png"></p><h3 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3gxz5yjj30u00t4abs.jpg" alt="image.png"></p><blockquote><p>从方法可以看出,我们关注点放在invoke()即可</p></blockquote><h3 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3h2obbzj30yg0b8wiu.jpg" alt="image.png"></p><blockquote><p>图中可以看出具体实现是调用父类TransactionAspectSupport的方法</p></blockquote><h2 id="TransactionAspectSupport"><a href="#TransactionAspectSupport" class="headerlink" title="TransactionAspectSupport"></a>TransactionAspectSupport</h2><h3 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3h5tk2ej30mo0dqmxn.jpg" alt="image.png"></p><h3 id="子类-可以发现子类不用多说了-注解开发"><a href="#子类-可以发现子类不用多说了-注解开发" class="headerlink" title="子类(可以发现子类不用多说了,注解开发)"></a>子类(可以发现子类不用多说了,注解开发)</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3hb4099j30yg02vmzv-20230318171242420.jpg" alt="image.png"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3he7ajnj30u012nn5j-20230318171245265.jpg" alt="image.png"></p><blockquote><p>可以发现,该父类已经提供了很多可用的方法</p></blockquote><p>需要着重关注这两个字段</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 线程隔离持有(下方会谈)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span>&lt;<span class="hljs-type">TransactionInfo</span>&gt; transactionInfoHolder <span class="hljs-operator">=</span><br>new <span class="hljs-type">NamedThreadLocal</span>&lt;<span class="hljs-type">TransactionInfo</span>&gt;(<span class="hljs-string">&quot;Current aspect-driven transaction&quot;</span>);<br><span class="hljs-comment">// 事务管理器(下方会谈)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">PlatformTransactionManager</span> transactionManager;<br></code></pre></td></tr></table></figure><p>先不谈getter&#x2F;setter,把重点放在根据命名比较核心的方法,总结如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">determineTransactionManager</span>()<br><span class="hljs-built_in">createTransactionIfNecessary</span>()<br><span class="hljs-built_in">prepareTransactionInfo</span>()<br><span class="hljs-built_in">invokeWithinTransaction</span>()  *<br><span class="hljs-built_in">commitTransactionAfterReturning</span>()<br><span class="hljs-built_in">completeTransactionAfterThrowing</span>()<br></code></pre></td></tr></table></figure><h4 id="determineTransactionManager"><a href="#determineTransactionManager" class="headerlink" title="determineTransactionManager()"></a>determineTransactionManager()</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3hjfe30j30yg0m4k11.jpg" alt="image.png"><br><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3j3ru4cj30yg07sdk2-20230318171253265.jpg" alt="image.png"></p><blockquote><p>通过这个方法可以发现是获取事务管理器(并放入缓存)</p></blockquote><h4 id="createTransactionIfNecessary"><a href="#createTransactionIfNecessary" class="headerlink" title="createTransactionIfNecessary()"></a>createTransactionIfNecessary()</h4><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3hnuwx7j30yg0jsagn.jpg" alt="image.png"></p><blockquote><p>通过这份方法命名可以发现是如果有必要则创建一个事务.<br>实际内容是获取TransactionAttribute和TransactionStatus(开启事务,AbstractPlatformTransactionManager详解),然后预处理TransactionInfo</p></blockquote><h3 id="prepareTransactionInfo"><a href="#prepareTransactionInfo" class="headerlink" title="prepareTransactionInfo()"></a>prepareTransactionInfo()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3hssydsj30yg0ln11p.jpg" alt="image.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindToThread</span>()</span> &#123;<br><span class="hljs-comment">// Expose current TransactionStatus, preserving any existing TransactionStatus</span><br><span class="hljs-comment">// for restoration after this transaction is complete.</span><br><span class="hljs-keyword">this</span>.oldTransactionInfo = transactionInfoHolder.<span class="hljs-keyword">get</span>();<br>transactionInfoHolder.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过这个方法可以发现是实例化TransactionInfo(多例)并绑定至事务持有器</p></blockquote><h3 id="invokeWithinTransaction"><a href="#invokeWithinTransaction" class="headerlink" title="invokeWithinTransaction()  *"></a>invokeWithinTransaction()  *</h3><blockquote><ul><li>表示最核心方法. ps:此方法较长无法截图因此直接放代码</li></ul></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected Object invoke<span class="hljs-constructor">WithinTransaction(Method <span class="hljs-params">method</span>, Class&lt;?&gt; <span class="hljs-params">targetClass</span>, <span class="hljs-params">final</span> InvocationCallback <span class="hljs-params">invocation</span>)</span><br>throws Throwable &#123;<br><br><span class="hljs-comment">// If the transaction attribute is null, the method is non-transactional.</span><br>final TransactionAttribute txAttr = get<span class="hljs-constructor">TransactionAttributeSource()</span>.get<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>, <span class="hljs-params">targetClass</span>)</span>;<br>final PlatformTransactionManager tm = determine<span class="hljs-constructor">TransactionManager(<span class="hljs-params">txAttr</span>)</span>;<br>final String joinpointIdentification = <span class="hljs-keyword">method</span><span class="hljs-constructor">Identification(<span class="hljs-params">method</span>, <span class="hljs-params">targetClass</span>, <span class="hljs-params">txAttr</span>)</span>;<br><br><span class="hljs-keyword">if</span> (txAttr<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>!(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;<br><span class="hljs-comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span><br>TransactionInfo txInfo = create<span class="hljs-constructor">TransactionIfNecessary(<span class="hljs-params">tm</span>, <span class="hljs-params">txAttr</span>, <span class="hljs-params">joinpointIdentification</span>)</span>;<br>Object retVal = null;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="hljs-comment">// This will normally result in a target object being invoked.</span><br>retVal = invocation.proceed<span class="hljs-constructor">WithInvocation()</span>;<br>&#125;<br>catch (Throwable ex) &#123;<br><span class="hljs-comment">// target invocation exception</span><br>complete<span class="hljs-constructor">TransactionAfterThrowing(<span class="hljs-params">txInfo</span>, <span class="hljs-params">ex</span>)</span>;<br>throw ex;<br>&#125;<br>finally &#123;<br>cleanup<span class="hljs-constructor">TransactionInfo(<span class="hljs-params">txInfo</span>)</span>;<br>&#125;<br>commit<span class="hljs-constructor">TransactionAfterReturning(<span class="hljs-params">txInfo</span>)</span>;<br>return retVal;<br>&#125;<br><br><span class="hljs-keyword">else</span> &#123;<br>final ThrowableHolder throwableHolder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThrowableHolder()</span>;<br><br><span class="hljs-comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span><br><span class="hljs-keyword">try</span> &#123;<br>Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,<br><span class="hljs-keyword">new</span> TransactionCallback&lt;Object&gt;<span class="hljs-literal">()</span> &#123;<br>@Override<br>public Object <span class="hljs-keyword">do</span><span class="hljs-constructor">InTransaction(TransactionStatus <span class="hljs-params">status</span>)</span> &#123;<br>TransactionInfo txInfo = prepare<span class="hljs-constructor">TransactionInfo(<span class="hljs-params">tm</span>, <span class="hljs-params">txAttr</span>, <span class="hljs-params">joinpointIdentification</span>, <span class="hljs-params">status</span>)</span>;<br><span class="hljs-keyword">try</span> &#123;<br>return invocation.proceed<span class="hljs-constructor">WithInvocation()</span>;<br>&#125;<br>catch (Throwable ex) &#123;<br><span class="hljs-keyword">if</span> (txAttr.rollback<span class="hljs-constructor">On(<span class="hljs-params">ex</span>)</span>) &#123;<br><span class="hljs-comment">// A RuntimeException: will lead to a rollback.</span><br><span class="hljs-keyword">if</span> (ex instanceof RuntimeException) &#123;<br>throw (RuntimeException) ex;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThrowableHolderException(<span class="hljs-params">ex</span>)</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// A normal return value: will lead to a commit.</span><br>throwableHolder.throwable = ex;<br>return null;<br>&#125;<br>&#125;<br>finally &#123;<br>cleanup<span class="hljs-constructor">TransactionInfo(<span class="hljs-params">txInfo</span>)</span>;<br>&#125;<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// Check result state: It might indicate a Throwable to rethrow.</span><br><span class="hljs-keyword">if</span> (throwableHolder.throwable != null) &#123;<br>throw throwableHolder.throwable;<br>&#125;<br>return result;<br>&#125;<br>catch (ThrowableHolderException ex) &#123;<br>throw ex.get<span class="hljs-constructor">Cause()</span>;<br>&#125;<br>catch (TransactionSystemException ex2) &#123;<br><span class="hljs-keyword">if</span> (throwableHolder.throwable != null) &#123;<br>logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);<br>ex2.init<span class="hljs-constructor">ApplicationException(<span class="hljs-params">throwableHolder</span>.<span class="hljs-params">throwable</span>)</span>;<br>&#125;<br>throw ex2;<br>&#125;<br>catch (Throwable ex2) &#123;<br><span class="hljs-keyword">if</span> (throwableHolder.throwable != null) &#123;<br>logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);<br>&#125;<br>throw ex2;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取TransactionAttribute(具体实现:SpringTransactionAnnotationParser.parseTransactionAnnotation())</li><li>获取事务管理器</li><li>获取事务属性描述符</li><li>如果TransactionAttribute &#x3D;&#x3D; null 或者事务管理器非回调<br>1.1 获取处理后的TransactionInfo(开启事务)</li><li>AOP执行代理方法<br>1.1  发生异常执行completeTransactionAfterThrowing(),并上抛<br>1.1 最终恢复当前线程旧事务(为事务嵌套预留)<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanupTransactionInfo</span>(<span class="hljs-params">TransactionInfo txInfo</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span>) &#123;<br>txInfo.restoreThreadLocalStatus();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreThreadLocalStatus</span>()</span> &#123;<br><span class="hljs-comment">// Use stack to restore old transaction TransactionInfo.</span><br><span class="hljs-comment">// Will be null if none was set.</span><br>transactionInfoHolder.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.oldTransactionInfo);<br>&#125;<br></code></pre></td></tr></table></figure>1.1 未发生异常执行commitTransactionAfterReturning()</li></ol><h3 id="commitTransactionAfterReturning"><a href="#commitTransactionAfterReturning" class="headerlink" title="commitTransactionAfterReturning()"></a>commitTransactionAfterReturning()</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">completeTransactionAfterThrowing</span><span class="hljs-params">(TransactionInfo txInfo, Throwable ex)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (txInfo != <span class="hljs-keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() +<br><span class="hljs-string">&quot;] after exception: &quot;</span> + ex);<br>&#125;<br><span class="hljs-keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());<br>&#125;<br><span class="hljs-keyword">catch</span> (TransactionSystemException ex2) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>ex2.initApplicationException(ex);<br><span class="hljs-keyword">throw</span> ex2;<br>&#125;<br><span class="hljs-keyword">catch</span> (RuntimeException ex2) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br><span class="hljs-keyword">throw</span> ex2;<br>&#125;<br><span class="hljs-keyword">catch</span> (Error err) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by rollback error&quot;</span>, ex);<br><span class="hljs-keyword">throw</span> err;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// We don&#x27;t roll back on this exception.</span><br><span class="hljs-comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span><br><span class="hljs-keyword">try</span> &#123;<br>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>&#125;<br><span class="hljs-keyword">catch</span> (TransactionSystemException ex2) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>ex2.initApplicationException(ex);<br><span class="hljs-keyword">throw</span> ex2;<br>&#125;<br><span class="hljs-keyword">catch</span> (RuntimeException ex2) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br><span class="hljs-keyword">throw</span> ex2;<br>&#125;<br><span class="hljs-keyword">catch</span> (Error err) &#123;<br>logger.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Application exception overridden by commit error&quot;</span>, ex);<br><span class="hljs-keyword">throw</span> err;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果TransactionInfo包含事务则执行回滚逻辑<br>1.1 如果属于回滚异常范围,则执行回滚<br>1.1 如果不属于回滚异常范围,则正常提交</li></ol><h3 id="completeTransactionAfterThrowing"><a href="#completeTransactionAfterThrowing" class="headerlink" title="completeTransactionAfterThrowing()"></a>completeTransactionAfterThrowing()</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3hz0x8lj30yg0auq7b-20230318171305245.jpg" alt="image.png"></p><blockquote><p>正常提交逻辑(ps: 同一个事务,如果A方法嵌套B方法,如果B方法抛出异常A捕获是否会走正常提交逻辑,如果走正常提交逻辑,事务最终是回滚还是提交? )</p></blockquote><h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3i2qq6xj30yg0o0dom.jpg" alt="image.png"></p><blockquote><p>子类(关注一下)<br><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3i6wm6lj30yg098ahw.jpg" alt="image.png"></p></blockquote><blockquote><p>事务传播属性</p></blockquote><h3 id="TransactionAttribute"><a href="#TransactionAttribute" class="headerlink" title="TransactionAttribute"></a>TransactionAttribute</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ia4udcj30yg0qkn5v-20230318171313398.jpg" alt="image.png"></p><blockquote><p>TransactionDefinition子类,增加rollbackOn(),定义回滚异常范围</p></blockquote><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ieh4a5j30gk0b8my9.jpg" alt="image.png"></p><blockquote><p>传递事务状态</p></blockquote><h3 id="TransactionInfo"><a href="#TransactionInfo" class="headerlink" title="TransactionInfo"></a>TransactionInfo</h3><p><img src="https://raw.githubusercontent.com/Gallrax/blog-image/master/uPic/0081Kckwly1gki3ihpbwsj30w80gwju0.jpg" alt="image.png"></p><ol><li>通过源码其实能够发现,事务提交回滚都是通过TransactionInfo.getTransactionManager().rollback()&#x2F;commit()</li><li>通过源码能够发现,判断方法发生异常是否回滚是通过TransactionInfo.transactionAttribute.rollbackOn(ex)决定</li><li>通过transactionStatus传递事务相关信息</li><li>通过源码发现oldTransactionInfo是用来暂存当前线程上一个事务(感觉命名可能不是特别好,也可能个人理解不够深)</li></ol><h2 id="将流程串起来"><a href="#将流程串起来" class="headerlink" title="将流程串起来"></a>将流程串起来</h2><ol><li>获取方法Transaction配置(详细后续)</li><li>获取事务管理器(PlatformTransactionManager)</li><li>开启事务并绑定线程上下文(详情后续)</li><li>执行代理方法</li><li>异常回滚,正常提交并恢复上一个事务(详情后续)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务相关代码比较多.此篇只是先写一下基础的流程框架.具体实现放在下一篇文章(可能在这个地方还并不能关注到spring设计的优雅,慢慢来)</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2018/04/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2018/04/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>此源码分析JDK版本为1.7，只是简单分析，算是个人看源码的一点小总结，随意性比较强，专业的还需百度。<br>先简单介绍一下HashMap，HashMap数据结构为数组加链表，时间复杂度为O(1)(最理想状态下)。HashMap源码中，需要推敲的代码非常的多，个人觉得比ArrayList、LinkedList等要有营养很多。个人觉得HashMap最主要关注的几个点：1.put()方法，2.hash()方法，3.size设置。关于hash()和size设置推荐一个博客可了解一下：<a href="https://blog.csdn.net/jiary5201314/article/details/51439982">深入理解HashMap（及hash函数的真正巧妙之处）</a><br>#简介</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;<br>    <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;<br>    <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>#属性</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//默认初始化长度16(可推敲一下为何为16)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-comment">//最大长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-comment">//默认扩容系数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><span class="hljs-comment">//空表实例</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;<br><span class="hljs-comment">//数据数组(存放Entry的数组)</span><br><span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;<br><span class="hljs-comment">//map大小</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br><span class="hljs-comment">//map阈值(到达该阈值扩容)</span><br><span class="hljs-keyword">int</span> threshold;<br><span class="hljs-comment">//扩容系数</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br><span class="hljs-comment">//修改次数</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><span class="hljs-comment">//默认的hash阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;<br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> hashSeed = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>#构造方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//根据初始化长度和扩容系数创建HashMap</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-comment">//如果初始化长度小于0抛异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-comment">//如果初始化长度超过默认最大长度则设置初始化为默认最大长度</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">//如果扩容系数小于等于0或者扩容系数不是一个合法的数字抛异常(比如参数为:0.0/0.0)</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br><br>    <span class="hljs-comment">//设置扩容系数</span><br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">//设置初始容量</span><br>    threshold = initialCapacity;<br>    <span class="hljs-comment">//初始化(方法为空)</span><br>    init();<br>&#125;<br><span class="hljs-comment">//创建初始化的的HashMap</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">//创建默认HashMap</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">//创建一个新的Map，将m的键值对放入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化长度和默认扩容因子的HashMap(根据默认的扩容因子计算是否小于默认大小，小于则按照默认大小)</span><br>    <span class="hljs-keyword">this</span>(Math.max((<span class="hljs-keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="hljs-number">1</span>,<br>                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<br>    <span class="hljs-comment">//</span><br>    inflateTable(threshold);<br><br>    putAllForCreate(m);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>#方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//返回格式化后大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> int <span class="hljs-title function_">roundUpToPowerOf2</span>(<span class="hljs-params">int <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br>    <span class="hljs-comment">//如果传入的值大于最大值，则返回最大值</span><br>    <span class="hljs-comment">//如果传入的的值大于1，则返回返回其对应的2的n次方值(Integer.highestOneBit(i))</span><br>    <span class="hljs-comment">//否则则返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span> &gt;= <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span><br>            ? <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span><br>            : (<span class="hljs-built_in">number</span> &gt; <span class="hljs-number">1</span>) ? <span class="hljs-title class_">Integer</span>.<span class="hljs-title function_">highestOneBit</span>((<span class="hljs-built_in">number</span> - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">inflateTable</span>(<span class="hljs-params">int toSize</span>) &#123;<br>    <span class="hljs-comment">// Find a power of 2 &gt;= toSize</span><br>    <span class="hljs-comment">//获取map大小</span><br>    int capacity = <span class="hljs-title function_">roundUpToPowerOf2</span>(toSize);<br>    <span class="hljs-comment">//获取map阈值</span><br>    threshold = (int) <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(capacity * loadFactor, <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//新建数组</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>    <span class="hljs-comment">//初始化HashSeed</span><br>    <span class="hljs-title function_">initHashSeedAsNeeded</span>(capacity);<br>&#125;<br><span class="hljs-comment">//初始化HashSeed(每次扩容时会使用)</span><br>final <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">initHashSeedAsNeeded</span>(<span class="hljs-params">int capacity</span>) &#123;<br>    <span class="hljs-built_in">boolean</span> currentAltHashing = hashSeed != <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">boolean</span> useAltHashing = sun.<span class="hljs-property">misc</span>.<span class="hljs-property">VM</span>.<span class="hljs-title function_">isBooted</span>() &amp;&amp;<br>            (capacity &gt;= <span class="hljs-title class_">Holder</span>.<span class="hljs-property">ALTERNATIVE_HASHING_THRESHOLD</span>);<br>    <span class="hljs-built_in">boolean</span> switching = currentAltHashing ^ useAltHashing;<br>    <span class="hljs-keyword">if</span> (switching) &#123;<br>        hashSeed = useAltHashing<br>            ? sun.<span class="hljs-property">misc</span>.<span class="hljs-property">Hashing</span>.<span class="hljs-title function_">randomHashSeed</span>(<span class="hljs-variable language_">this</span>)<br>            : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> switching;<br>&#125;<br><span class="hljs-comment">//hash实现</span><br>final int <span class="hljs-title function_">hash</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> k</span>) &#123;<br>    int h = hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;<br>        <span class="hljs-keyword">return</span> sun.<span class="hljs-property">misc</span>.<span class="hljs-property">Hashing</span>.<span class="hljs-title function_">stringHash32</span>((<span class="hljs-title class_">String</span>) k);<br>    &#125;<br><br>    h ^= k.<span class="hljs-title function_">hashCode</span>();<br><br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">//根据哈希值和长度获取下标</span><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">indexFor</span>(<span class="hljs-params">int h, int length</span>) &#123;<br>    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//获取大小(真实数据的大小，非数组长度)</span><br><span class="hljs-keyword">public</span> int <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><span class="hljs-comment">//判断大小是否为空</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//根据key获取值</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> key</span>) &#123;<br>    <span class="hljs-comment">//如果key为null，则根据null去获取值</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getForNullKey</span>();<br>    <span class="hljs-comment">//key不为null则根据key获取Entry</span><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; entry = <span class="hljs-title function_">getEntry</span>(key);<br>    <span class="hljs-comment">//根据entry是否为null获取值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == entry ? <span class="hljs-literal">null</span> : entry.<span class="hljs-title function_">getValue</span>();<br>&#125;<br><span class="hljs-comment">//根据key为null获取值</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">getForNullKey</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//如果size为0则直接返回null</span><br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//因为key为null直接放在数组第一个位置，因此遍历数组第一个下得Entry链表即可</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> e.<span class="hljs-property">value</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果没有则返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//根据key获取Entry</span><br>final <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-title function_">getEntry</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> key</span>) &#123;<br>    <span class="hljs-comment">//如果size为0则直接返回null</span><br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//根据key是否等于null获取key的hash值</span><br>    int hash = (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-title function_">hash</span>(key);<br>    <span class="hljs-comment">//根据hash值来获取该key对应的数组下标，遍历该下标下对应的链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = table[<span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>)];<br>         e != <span class="hljs-literal">null</span>;<br>         e = e.<span class="hljs-property">next</span>) &#123;<br>        <span class="hljs-title class_">Object</span> k;<br>        <span class="hljs-comment">//如果hash值相等并且(key地址相同或者key相等)则返回</span><br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp;<br>            ((k = e.<span class="hljs-property">key</span>) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-title function_">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-comment">//说明并没有该值返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//是否包含键key</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">containsKey</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> key</span>) &#123;<br>    <span class="hljs-comment">//根据key获取Entry是否为null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getEntry</span>(key) != <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//放入键值对</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(<span class="hljs-params">K key, V value</span>) &#123;<br>    <span class="hljs-comment">//如果数组为空则初始化数组</span><br>    <span class="hljs-keyword">if</span> (table == <span class="hljs-variable constant_">EMPTY_TABLE</span>) &#123;<br>        <span class="hljs-title function_">inflateTable</span>(threshold);<br>    &#125;<br>    <span class="hljs-comment">//如果key为null则根据key为null放入</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-comment">//获取key所对应的hash值</span><br>    int hash = <span class="hljs-title function_">hash</span>(key);<br>    <span class="hljs-comment">//获取该key所对应的hash值所对应数组的下标</span><br>    int i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-comment">//遍历该数组下标的链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<br>        <span class="hljs-title class_">Object</span> k;<br>        <span class="hljs-comment">//如果该key已经存在，则覆盖旧值并返回</span><br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == key || key.<span class="hljs-title function_">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            <span class="hljs-comment">//该方法为空，未知此方法干什么用</span><br>            e.<span class="hljs-title function_">recordAccess</span>(<span class="hljs-variable language_">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//修改次数增加</span><br>    modCount++;<br>    <span class="hljs-comment">//到此步则说明没有改key，则新增Entry</span><br>    <span class="hljs-title function_">addEntry</span>(hash, key, value, i);<br>    <span class="hljs-comment">//新增Entry返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//放入Map</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">putAll</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m</span>) &#123;<br>    <span class="hljs-comment">//获取m的大小</span><br>    int numKeysToBeAdded = m.<span class="hljs-title function_">size</span>();<br>    <span class="hljs-comment">//如果size为0则直接返回</span><br>    <span class="hljs-keyword">if</span> (numKeysToBeAdded == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//如果当前数组为空则扩容</span><br>    <span class="hljs-keyword">if</span> (table == <span class="hljs-variable constant_">EMPTY_TABLE</span>) &#123;<br>        <span class="hljs-title function_">inflateTable</span>((int) <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(numKeysToBeAdded * loadFactor, threshold));<br>    &#125;<br>    <span class="hljs-comment">//如果放入的m的size超过当前map的阈值则初始化</span><br>    <span class="hljs-keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;<br>        <span class="hljs-comment">//计算m扩容后的大小</span><br>        int targetCapacity = (int)(numKeysToBeAdded / loadFactor + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (targetCapacity &gt; <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span>)<br>            targetCapacity = <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span>;<br>        <span class="hljs-comment">//计算当前数组扩容后的大小</span><br>        int newCapacity = table.<span class="hljs-property">length</span>;<br>        <span class="hljs-comment">//循环扩大(a&lt;&lt;=1 等价于 a = a &lt;&lt; 1)</span><br>        <span class="hljs-keyword">while</span> (newCapacity &lt; targetCapacity)<br>            newCapacity &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (newCapacity &gt; table.<span class="hljs-property">length</span>)<br>            <span class="hljs-title function_">resize</span>(newCapacity);<br>    &#125;<br>    <span class="hljs-comment">//遍历m将entry放入当前map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.<span class="hljs-title function_">entrySet</span>())<br>        <span class="hljs-title function_">put</span>(e.<span class="hljs-title function_">getKey</span>(), e.<span class="hljs-title function_">getValue</span>());<br>&#125;<br><span class="hljs-comment">//新增Entry</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">addEntry</span>(<span class="hljs-params">int hash, K key, V value, int bucketIndex</span>) &#123;<br>    <span class="hljs-comment">//如果size大于等与扩容阈值并且该下标不为空</span><br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>        <span class="hljs-comment">//扩容</span><br>        <span class="hljs-title function_">resize</span>(<span class="hljs-number">2</span> * table.<span class="hljs-property">length</span>);<br>        <span class="hljs-comment">//重新hash</span><br>        hash = (<span class="hljs-literal">null</span> != key) ? <span class="hljs-title function_">hash</span>(key) : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取该hash对应的下标</span><br>        bucketIndex = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    &#125;<br>    创建<span class="hljs-title class_">Entry</span><br>    <span class="hljs-title function_">createEntry</span>(hash, key, value, bucketIndex);<br>&#125;<br><span class="hljs-comment">//创建Entry</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">createEntry</span>(<span class="hljs-params">int hash, K key, V value, int bucketIndex</span>) &#123;<br>    <span class="hljs-comment">//获取该下标下的第一个Entry</span><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = table[bucketIndex];<br>    <span class="hljs-comment">//将新建的Entry放至该数组下链表第一个(新Entry的next指向就得Entry)</span><br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    <span class="hljs-comment">//size+1</span><br>    size++;<br>&#125;<br><span class="hljs-comment">//扩容</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">int newCapacity</span>) &#123;<br>    <span class="hljs-title class_">Entry</span>[] oldTable = table;<br>    int oldCapacity = oldTable.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">//如果旧数组的长度已经到达最大，则返回将扩容阈值设置为最大值</span><br>    <span class="hljs-keyword">if</span> (oldCapacity == <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span>) &#123;<br>        threshold = <span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//新建该长度的数组</span><br>    <span class="hljs-title class_">Entry</span>[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    <span class="hljs-comment">//转换</span><br>    <span class="hljs-title function_">transfer</span>(newTable, <span class="hljs-title function_">initHashSeedAsNeeded</span>(newCapacity));<br>    <span class="hljs-comment">//将table地址指向新的地址</span><br>    table = newTable;<br>    <span class="hljs-comment">//设置扩容阈值</span><br>    threshold = (int)<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(newCapacity * loadFactor, <span class="hljs-variable constant_">MAXIMUM_CAPACITY</span> + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//转换</span><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">Entry[] newTable, <span class="hljs-built_in">boolean</span> rehash</span>) &#123;<br>    <span class="hljs-comment">//定义数组长度</span><br>    int newCapacity = newTable.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">//遍历数组Entry</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span>&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            <span class="hljs-title class_">Entry</span>&lt;K,V&gt; next = e.<span class="hljs-property">next</span>;<br>            <span class="hljs-comment">//如果重新hash则需要重新设置e的hash值</span><br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.<span class="hljs-property">hash</span> = <span class="hljs-literal">null</span> == e.<span class="hljs-property">key</span> ? <span class="hljs-number">0</span> : <span class="hljs-title function_">hash</span>(e.<span class="hljs-property">key</span>);<br>            &#125;<br>            <span class="hljs-comment">//根据e的hash值获取e的新的下标</span><br>            int i = <span class="hljs-title function_">indexFor</span>(e.<span class="hljs-property">hash</span>, newCapacity);<br>            <span class="hljs-comment">//将下标为i的Entry赋予为当前Entry的next</span><br>            e.<span class="hljs-property">next</span> = newTable[i];<br>            <span class="hljs-comment">//将当前Entry赋予newTable的i下标(因为上一步已经将之前的Entry赋予为当前的next，所以直接将引用指向新的即可)</span><br>            newTable[i] = e;<br>            <span class="hljs-comment">//将下一个Entry赋予为e继续循环</span><br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//根据key移除元素</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> key</span>) &#123;<br>    <span class="hljs-comment">//根据key移除元素</span><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = <span class="hljs-title function_">removeEntryForKey</span>(key);<br>    <span class="hljs-comment">//返回值</span><br>    <span class="hljs-keyword">return</span> (e == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.<span class="hljs-property">value</span>);<br>&#125;<br><span class="hljs-comment">//根据key移除Entry</span><br>final <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-title function_">removeEntryForKey</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> key</span>) &#123;<br>    <span class="hljs-comment">//如果当前大小为0则返回null</span><br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//获取key的hash值</span><br>    int hash = (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-title function_">hash</span>(key);<br>    <span class="hljs-comment">//根据key的hash值返回下标</span><br>    int i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-comment">//获取当前下标的Entry</span><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; prev = table[i];<br>    <span class="hljs-comment">//将当前下标的Entry赋予给e</span><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = prev;<br>    <span class="hljs-comment">//循环判断</span><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//获取当前Entry的下一个Entry</span><br>        <span class="hljs-title class_">Entry</span>&lt;K,V&gt; next = e.<span class="hljs-property">next</span>;<br>        <span class="hljs-comment">//定义临时变量k</span><br>        <span class="hljs-title class_">Object</span> k;<br>        <span class="hljs-comment">//如果当前Entry的hash值和key的hash值相同并且(当前Entry的key和key地址相同或者值相同)则进入</span><br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp;<br>            ((k = e.<span class="hljs-property">key</span>) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-title function_">equals</span>(k)))) &#123;<br>            <span class="hljs-comment">//修改次数+1</span><br>            modCount++;<br>            <span class="hljs-comment">//大小-1</span><br>            size--;<br>            <span class="hljs-comment">//如果prev为当前Entry则说明该Entry是链表第一个元素，则直接将第一个元素指向该Entry的next即可</span><br>            <span class="hljs-keyword">if</span> (prev == e)<br>                table[i] = next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//如果不是链表的第一个元素则将当前元素上一个元素的next指向当前元素的下一个元素即可</span><br>                prev.<span class="hljs-property">next</span> = next;<br>            <span class="hljs-comment">//未知该代码什么作用(代码内容为空)</span><br>           e.<span class="hljs-title function_">recordRemoval</span>(<span class="hljs-variable language_">this</span>);<br>            <span class="hljs-comment">//返回旧值</span><br>            <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        <span class="hljs-comment">//如果当前元素并不是要删除的元素则将当前元素赋予上一个元素prev，将下一个元素指向当前元素e，继续循环</span><br>        prev = e;<br>        e = next;<br>    &#125;<br>    <span class="hljs-comment">//走到这一步说明没有该元素，此时e已经为null，返回</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><span class="hljs-comment">//删除Entry</span><br>final <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-title function_">removeMapping</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>    <span class="hljs-comment">//如果当前map大小为0或者不是MapEntry类型则返回null</span><br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span> || !(o <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//强转为Map.Entry类型</span><br>    <span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;K,V&gt; entry = (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;K,V&gt;) o;<br>    <span class="hljs-comment">//获取key</span><br>    <span class="hljs-title class_">Object</span> key = entry.<span class="hljs-title function_">getKey</span>();<br>    <span class="hljs-comment">//下方代码和removeEntryForKey一致除了该判断是判断entry的hash和值(个人觉得完全可以在此调用根据key删除)</span><br>    int hash = (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-title function_">hash</span>(key);<br>    int i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br><br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; prev = table[i];<br>    <span class="hljs-title class_">Entry</span>&lt;K,V&gt; e = prev;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-title class_">Entry</span>&lt;K,V&gt; next = e.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; e.<span class="hljs-title function_">equals</span>(entry)) &#123;<br>            modCount++;<br>            size--;<br>            <span class="hljs-keyword">if</span> (prev == e)<br>                table[i] = next;<br>            <span class="hljs-keyword">else</span><br>                prev.<span class="hljs-property">next</span> = next;<br>            e.<span class="hljs-title function_">recordRemoval</span>(<span class="hljs-variable language_">this</span>);<br>            <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        prev = e;<br>        e = next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><span class="hljs-comment">//清空map</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//修改次数+1</span><br>    modCount++;<br>    <span class="hljs-comment">//调用工具类(内部实现为遍历数组，将数组每个下标的元素指向null，此时扩容阈值threshold还是旧的)</span><br>    <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">fill</span>(table, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//设置大小为0</span><br>    size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//是否包含值</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">containsValue</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> value</span>) &#123;<br>    <span class="hljs-comment">//如果值为null则调用是否包含空值方法</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">containsNullValue</span>();<br>    <span class="hljs-comment">//定义临时变量指向当前数组</span><br>    <span class="hljs-title class_">Entry</span>[] tab = table;<br>    <span class="hljs-comment">//遍历数组</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; tab.<span class="hljs-property">length</span> ; i++)<br>        <span class="hljs-comment">//遍历当前Entry链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span> e = tab[i] ; e != <span class="hljs-literal">null</span> ; e = e.<span class="hljs-property">next</span>)<br>            <span class="hljs-comment">//如果相同则返回true</span><br>            <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">equals</span>(e.<span class="hljs-property">value</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//说明不好看此值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//是否包含空值(私有)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">containsNullValue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//方法体和判断值相同，只不过是判断是否为null</span><br>    <span class="hljs-title class_">Entry</span>[] tab = table;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; tab.<span class="hljs-property">length</span> ; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span> e = tab[i] ; e != <span class="hljs-literal">null</span> ; e = e.<span class="hljs-property">next</span>)<br>            <span class="hljs-keyword">if</span> (e.<span class="hljs-property">value</span> == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//克隆</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; result = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        调用<span class="hljs-title class_">Object</span>的克隆方法(浅克隆)<br>        result = (<span class="hljs-title class_">HashMap</span>&lt;K,V&gt;)<span class="hljs-variable language_">super</span>.<span class="hljs-title function_">clone</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">CloneNotSupportedException</span> e) &#123;<br>        <span class="hljs-comment">// assert false;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">table</span> != <span class="hljs-variable constant_">EMPTY_TABLE</span>) &#123;<br>        <span class="hljs-comment">//刷新HashSeed</span><br>        result.<span class="hljs-title function_">inflateTable</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<br>            (int) <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<br>                size * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span> / loadFactor, <span class="hljs-number">4.</span>0f),<br>                <span class="hljs-comment">// we have limits...</span><br>                <span class="hljs-title class_">HashMap</span>.<span class="hljs-property">MAXIMUM_CAPACITY</span>),<br>           table.<span class="hljs-property">length</span>));<br>    &#125;<br>    <span class="hljs-comment">//以下类似于初始化</span><br>    result.<span class="hljs-property">entrySet</span> = <span class="hljs-literal">null</span>;<br>    result.<span class="hljs-property">modCount</span> = <span class="hljs-number">0</span>;<br>    result.<span class="hljs-property">size</span> = <span class="hljs-number">0</span>;<br>    result.<span class="hljs-title function_">init</span>();<br>    <span class="hljs-comment">//此处将旧的数据放入克隆之后的result</span><br>    result.<span class="hljs-title function_">putAllForCreate</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">//返回result</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-comment">//tag:Entry比较简单，代码量也少，就不分析了</span><br></code></pre></td></tr></table></figure><p>#总结</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>获取值是先计算其<span class="hljs-built_in">hash</span>值，再根据其<span class="hljs-built_in">hash</span>值获取数组下标，然后遍历该下标对应的链表去取值<br><span class="hljs-number">2.</span>放入键值对则是先计算key的<span class="hljs-built_in">hash</span>值，根据<span class="hljs-built_in">hash</span>值获取数组下标，遍历查看是否有其对应的值，有则覆盖，没有则新增Entry<br><span class="hljs-number">3.</span>新增Entry时会先判断是否需要扩容，再创建Entry。创建Entry只需要将新的Entry放置该数组位置，将<span class="hljs-built_in">next</span>指向旧的头节点<br><span class="hljs-number">4.</span>扩容是两倍扩容，根据是否重新<span class="hljs-built_in">hash</span>而决定是否更改Entry的<span class="hljs-built_in">hash</span>值，然后遍历获取新的数组下标将旧数据放置新的数组中，再将旧的数组指向新的数组<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>jdk</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="/2018/04/03/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2018/04/03/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>此源码分析JDK版本为1.7，只是简单分析，算是个人看源码的一点小总结，随意性比较强，专业的还需百度。<br>先简单介绍一下LinkedList，LinkedList为直线型的链表结构，时间复杂度为O(n)。ArrayList内部存储为数组，LinkedList内部存储为节点Node。以下所有表达LinkedList的内容统称为链表。<br>#简介</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">AbstractSequentialList</span></span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">List</span></span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>#属性</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//链表大小</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//链表头部节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-comment">//链表尾部节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><p>#构造方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//无初始化集合构造方法</span><br>public <span class="hljs-built_in">LinkedList</span>() &#123;<br>&#125;<br><span class="hljs-comment">//初始化集合构造方法</span><br>public <span class="hljs-built_in">LinkedList</span>(Collection&lt;? extends E&gt; c) &#123;<br>    <span class="hljs-built_in">this</span>();<br>    <span class="hljs-built_in">addAll</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>#Node</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//当前节点存放的值</span><br>    E item;<br>    <span class="hljs-comment">//当前节点前一个节点</span><br>    Node&lt;E&gt; <span class="hljs-keyword">next</span>;<br>    <span class="hljs-comment">//当前节点后一个节点</span><br>    Node&lt;E&gt; prev;<br><br>    <span class="hljs-comment">//全参构造方法</span><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将值放置第一个节点(私有)，此方法可发现增加效率比ArrayList高很多，无需移动其他节点<br>private void linkFirst(E e) &#123;<br>    <span class="hljs-regexp">//</span>将链表第一个节点地址赋予f<br>    final Node&lt;E&gt; f = first;<br>    <span class="hljs-regexp">//</span>创建节点对象<br>    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);<br>    <span class="hljs-regexp">//</span>将新的节点对象地址赋予first<br>    first = newNode;<br>    <span class="hljs-regexp">//</span>如果f为空，则说明之前链表没有节点<br>    <span class="hljs-keyword">if</span> (f == null)<br>        <span class="hljs-regexp">//</span>最后一个节点即第一个节点<br>        last = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>f不为空，则f的上一个节点为第一个节点(节点f由第一个变为第二个)<br>        f.prev = newNode;<br>    <span class="hljs-regexp">//</span>大小+<span class="hljs-number">1</span><br>    size++;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>&#125;<br><span class="hljs-regexp">//</span>将值放置最后一个节点(default，该类及同包可使用)，add()会调用该方法，此方法可发现增加效率比ArrayList高很多，无需移动其他节点<br>void linkLast(E e) &#123;<br>    <span class="hljs-regexp">//</span>将链表第一个节点地址赋予l<br>    final Node&lt;E&gt; l = last;<br>    <span class="hljs-regexp">//</span>创建节点对象<br>    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);<br>    <span class="hljs-regexp">//</span>将新的节点对象地址赋予last <br>    last = newNode;<br>    <span class="hljs-regexp">//</span>如果l为空，则说明之前链表没有节点<br>    <span class="hljs-keyword">if</span> (l == null)<br>        <span class="hljs-regexp">//</span>第一个节点即最后一个节点<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>l不为空，则l的下一个节点为最后一个节点(节点l由倒数第一个变为倒数第二个)<br>        l.<span class="hljs-keyword">next</span> = newNode;<br>    <span class="hljs-regexp">//</span>大小+<span class="hljs-number">1</span><br>    size++;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>&#125;<br><span class="hljs-regexp">//</span>在succ节点前加入e(default，该类及同包可使用)，add()方法会调用该方法，此方法可发现增加效率比ArrayList高很多，无需移动其他节点<br>void linkBefore(E e, Node&lt;E&gt; succ) &#123;<br>    <span class="hljs-regexp">//</span>succ不能为null(方法声明为default，则说明不为null的话，succ一定存在于该链表)<br>    <span class="hljs-regexp">//</span> assert succ != null;<br>    <span class="hljs-regexp">//</span>succ的上一个节点赋予pred<br>    final Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-regexp">//</span>创建节点对象(上个节点：pred，当前节点：e，下一个节点：succ)<br>    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);<br>    <span class="hljs-regexp">//</span>将新的节点对象赋予为succ的上一个节点<br>    succ.prev = newNode;<br>    <span class="hljs-regexp">//</span>pred为null则说明succ为第一个节点<br>    <span class="hljs-keyword">if</span> (pred == null)<br>        <span class="hljs-regexp">//</span>将新的节点对象作为第一个节点<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>pred不为null则说明不是第一个对象，将新的节点对象作为pred的下一个对象<br>        pred.<span class="hljs-keyword">next</span> = newNode;<br>    <span class="hljs-regexp">//</span>大小+<span class="hljs-number">1</span><br>    size++;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>&#125;<br><span class="hljs-regexp">//</span>删除第一个节点(私有)，remove()，removeFirst()会调用此方法， 此方法可发现移出效率比ArrayList高很多，无需移动其他节点<br>private E unlinkFirst(Node&lt;E&gt; f) &#123;<br>    <span class="hljs-regexp">//</span>f不能为null并且f必须是第一个节点<br>    <span class="hljs-regexp">//</span> assert f == first &amp;&amp; f != null;<br>    <span class="hljs-regexp">//</span>获取当前节点f的值<br>    final E element = f.item;<br>    <span class="hljs-regexp">//</span>获取当前节点f的下一个节点<br>    final Node&lt;E&gt; <span class="hljs-keyword">next</span> = f.<span class="hljs-keyword">next</span>;<br>    <span class="hljs-regexp">//</span>将当前节点f置null<br>    f.item = null;<br>    <span class="hljs-regexp">//</span>将f下个节点置null<br>    f.<span class="hljs-keyword">next</span> = null; <span class="hljs-regexp">//</span> help GC<br>    <span class="hljs-regexp">//</span>将<span class="hljs-keyword">next</span>赋予第一个节点<br>    first = <span class="hljs-keyword">next</span>;<br>    <span class="hljs-regexp">//</span>如果<span class="hljs-keyword">next</span>为null则说明该链表只有f一个节点<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> == null)<br>        <span class="hljs-regexp">//</span>将last置null<br>        last = null;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>如果<span class="hljs-keyword">next</span>不为null则说明该链表不止一个节点，将<span class="hljs-keyword">next</span>的上一个节点置null(此时<span class="hljs-keyword">next</span>为第一个节点)<br>        <span class="hljs-keyword">next</span>.prev = null;<br>    <span class="hljs-regexp">//</span>大小-<span class="hljs-number">1</span><br>    size--;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>    return element;<br>&#125;<br><span class="hljs-regexp">//</span>删除最后一个节点(私有)，此方法可发现移出效率比ArrayList高很多，无需移动其他节点<br>private E unlinkLast(Node&lt;E&gt; l) &#123;<br>    <span class="hljs-regexp">//</span>l不能为null并且l必须是最后一个节点<br>    <span class="hljs-regexp">//</span> assert l == last &amp;&amp; l != null;<br>    <span class="hljs-regexp">//</span>获取当前节点l的值<br>    final E element = l.item;<br>    <span class="hljs-regexp">//</span>获取当前节点l的上一个节点<br>    final Node&lt;E&gt; prev = l.prev;<br>    <span class="hljs-regexp">//</span>将当前节点l的值置null<br>    l.item = null;<br>    <span class="hljs-regexp">//</span>将l下个节点置null<br>    l.prev = null; <span class="hljs-regexp">//</span> help GC<br>    <span class="hljs-regexp">//</span>将prev赋予最后一个节点<br>    last = prev;<br>    <span class="hljs-regexp">//</span>如果prev为null则说明该链表只有f一个节点<br>    <span class="hljs-keyword">if</span> (prev == null)<br>        <span class="hljs-regexp">//</span>将first 置null<br>        first = null;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>如果prev不为null则说明该链表不止一个节点，将prev的下一个节点置null(此时prev为最后一个节点)<br>        prev.<span class="hljs-keyword">next</span> = null;<br>    <span class="hljs-regexp">//</span>大小-<span class="hljs-number">1</span><br>    size--;<br>    modCount++;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    return element;<br>&#125;<br><span class="hljs-regexp">//</span>移出x节点(default，该类及同包可使用)，remove(index/o)会调用此方法，此方法可发现增加效率比ArrayList高很多，无需移动其他节点<br>E unlink(Node&lt;E&gt; x) &#123;<br>    <span class="hljs-regexp">//</span>x不能为null(方法声明为default，则说明不为null的话，succ一定存在于该链表)<br>    <span class="hljs-regexp">//</span> assert x != null;<br>    <span class="hljs-regexp">//</span>将节点x的值赋予element<br>    final E element = x.item;<br>    <span class="hljs-regexp">//</span>将节点x的下个节点赋予<span class="hljs-keyword">next</span><br>    final Node&lt;E&gt; <span class="hljs-keyword">next</span> = x.<span class="hljs-keyword">next</span>;<br>    <span class="hljs-regexp">//</span>将节点x的上个节点赋予prev<br>    final Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-regexp">//</span>当prev为null，说明x节点为第一个节点<br>    <span class="hljs-keyword">if</span> (prev == null) &#123;<br>        <span class="hljs-regexp">//</span>将<span class="hljs-keyword">next</span>赋予为第一个节点<br>        first = <span class="hljs-keyword">next</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>当prev不为null，说明x节点为中间节点，将下个节点赋予为上个节点的下个节点<br>        prev.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        <span class="hljs-regexp">//</span>x节点的下个节点置null<br>        x.prev = null;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>当<span class="hljs-keyword">next</span>为null，说明x节点为最后一个节点<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> == null) &#123;<br>        <span class="hljs-regexp">//</span>将prev赋予为最后一个节点<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>当<span class="hljs-keyword">next</span>不为null，说明x节点为中间节点，将上个节点赋予为上个节点的上个节点<br>        <span class="hljs-keyword">next</span>.prev = prev;<br>        <span class="hljs-regexp">//</span>x节点的上个节点置null<br>        x.<span class="hljs-keyword">next</span> = null;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>x节点的值置null<br>    x.item = null;<br>    <span class="hljs-regexp">//</span>大小-<span class="hljs-number">1</span><br>    size--;<br>    <span class="hljs-regexp">//</span>修改次数+<br>    modCount++;<br>    return element;<br>&#125;<br><span class="hljs-regexp">//</span>获取第一个节点的值<br>public E getFirst() &#123;<br>    final Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == null)<br>        throw new NoSuchElementException();<br>    return f.item;<br>&#125;<br><span class="hljs-regexp">//</span>获取最后一个节点的值<br>public E getLast() &#123;<br>    final Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == null)<br>        throw new NoSuchElementException();<br>    return l.item;<br>&#125;<br><span class="hljs-regexp">//</span>移除第一个节点的值<br>public E removeFirst() &#123;<br>    final Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == null)<br>        throw new NoSuchElementException();<br>    <span class="hljs-regexp">//</span>调用unlinkFirst()方法<br>    return unlinkFirst(f);<br>&#125;<br><span class="hljs-regexp">//</span>移除最后一个节点值<br>public E removeLast() &#123;<br>    final Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">if</span> (l == null)<br>        throw new NoSuchElementException();<br>    <span class="hljs-regexp">//</span>调用unlinkLast()方法<br>    return unlinkLast(l);<br>&#125;<br><span class="hljs-regexp">//</span>将值放置第一个节点<br>public void addFirst(E e) &#123;<br>    <span class="hljs-regexp">//</span>调用linkFirst()方法<br>    linkFirst(e);<br>&#125;<br><span class="hljs-regexp">//</span>将值放置最后一个节点<br>public void addLast(E e) &#123;<br>    <span class="hljs-regexp">//</span>调用linkLast()方法<br>    linkLast(e);<br>&#125;<br><span class="hljs-regexp">//</span>获取元素的第一个下标<br>public int indexOf(Object o) &#123;<br>    int index = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span>如果o为null，则遍历所有节点查询(说明LinkedList是支持null值的)<br>    <span class="hljs-keyword">if</span> (o == null) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == null)<br>                return index;<br>            <span class="hljs-regexp">//</span>因为LinkedList为链表结构，没有下标，因为临时index充当下标(index是从<span class="hljs-number">0</span>开始，因此应该后++)<br>            index++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                return index;<br>            <span class="hljs-regexp">//</span>因为LinkedList为链表结构，没有下标，因为临时index充当下标(index是从<span class="hljs-number">0</span>开始，因此应该后++)<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-regexp">//</span>无该值<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-regexp">//</span>获取元素的最后一个下标<br>public int lastIndexOf(Object o) &#123;<br>    int index = size;<br>    <span class="hljs-regexp">//</span>如果o为null，则遍历所有节点查询(说明LinkedList是支持null值的)<br>    <span class="hljs-keyword">if</span> (o == null) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;<br>            <span class="hljs-regexp">//</span>因为LinkedList为链表结构，没有下标，因为临时index充当下标(index是从<span class="hljs-number">0</span>开始，因此应该先--)<br>            index--;<br>            <span class="hljs-keyword">if</span> (x.item == null)<br>                return index;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;<br>            <span class="hljs-regexp">//</span>因为LinkedList为链表结构，没有下标，因为临时index充当下标(index是从<span class="hljs-number">0</span>开始，因此应该先--)<br>            index--;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item))<br>                return index;<br>        &#125;<br>    &#125;<br>    return -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-regexp">//</span>是否包含值<br>public boolean contains(Object o) &#123;<br>    <span class="hljs-regexp">//i</span>ndexOf()方法解析可发现此方法会遍历所有，因此应当尽可能少使用<br>    return indexOf(o) != -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-regexp">//</span>返回链表大小<br>public int size() &#123;<br>    return size;<br>&#125;<br><span class="hljs-regexp">//</span>增加值<br>public boolean add(E e) &#123;<br>    <span class="hljs-regexp">//</span>默认在最后增加节点()<br>    linkLast(e);<br>    return true;<br>&#125;<br><span class="hljs-regexp">//</span>删除值<br>public boolean remove(Object o) &#123;<br>    <span class="hljs-regexp">//</span>如果值为null，则删除第一个值为null的节点<br>    <span class="hljs-keyword">if</span> (o == null) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == null) &#123;<br>                <span class="hljs-regexp">//</span>调用unlink()方法<br>                unlink(x);<br>                return true;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span>如果值不为null，则删除第一个值为o的节点<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                <span class="hljs-regexp">//</span>调用unlink()方法<br>                unlink(x);<br>                return true;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return false;<br>&#125;<br><span class="hljs-regexp">//</span>参数是否为现有元素的索引<br>private boolean isElementIndex(int index) &#123;<br>    return index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>&#125;<br><span class="hljs-regexp">//</span>是否是迭代器或添加操作的有效位置的索引<br>private boolean isPositionIndex(int index) &#123;<br>    return index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= size;<br>&#125;<br><span class="hljs-regexp">//</span>检查是否为现有元素的索引<br>private void checkElementIndex(int index) &#123;<br>    <span class="hljs-keyword">if</span> (!isElementIndex(index))<br>        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-regexp">//</span>检查是否为迭代器或添加操作的有效位置的索引(最大现有元素下标+<span class="hljs-number">1</span>)<br>private void checkPositionIndex(int index) &#123;<br>    <span class="hljs-keyword">if</span> (!isPositionIndex(index))<br>        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-regexp">//</span>根据下标获取节点 (类似二分查询法)<br>Node&lt;E&gt; node(int index) &#123;<br>    <span class="hljs-regexp">//</span>应当保证是有值下标，但是并没有保证<br>    <span class="hljs-regexp">//</span> assert isElementIndex(index);<br><br>    <span class="hljs-regexp">//</span>如果index小于size的一半，则通过x.<span class="hljs-keyword">next</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-regexp">//</span>从first开始<span class="hljs-keyword">next</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.<span class="hljs-keyword">next</span>;<br>        return x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>如果index大于等于size，则通过x.prev<br>        <span class="hljs-regexp">//</span>从last开始<span class="hljs-keyword">next</span><br>        Node&lt;E&gt; x = prev;<br>        <span class="hljs-keyword">for</span> (int i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        return x;<br>    &#125;<br>&#125;<br><span class="hljs-regexp">//</span>在index之后加入集合<br>public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;<br>    <span class="hljs-regexp">//</span>检查下标是否为添加操作的有效位置的索引<br>    checkPositionIndex(index);<br><br>    <span class="hljs-regexp">//</span>转换为数组<br>    Object[] a = c.toArray();<br>    <span class="hljs-regexp">//</span>数组a的长度<br>    int numNew = a.length;<br>    <span class="hljs-regexp">//</span>如果数组长度为<span class="hljs-number">0</span>则返回false<br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        return false;<br><br>    <span class="hljs-regexp">//</span>新建pred(上一个节点)、succ(下一个节点)<br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-regexp">//</span>如果index和链表长度相同，则说明要在最后的位置加入节点<br>    <span class="hljs-keyword">if</span> (index == size) &#123;<br>        <span class="hljs-regexp">//</span>下一个节点为null<br>        succ = null;<br>        <span class="hljs-regexp">//</span>上一个节点为链表最后一个节点<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>如果index和链表长度不相同，则说明要在中间位置加入节点<br>        <span class="hljs-regexp">//</span>将当前下标节点赋予succ节点(下一个节点)<br>        succ = node(index);<br>        <span class="hljs-regexp">//</span>将当前下标节点的上一个节点赋予pred节点(上一个节点)<br>        pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>遍历数组a<br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>) E e = (E) o;<br>        <span class="hljs-regexp">//</span>新建一个对象(当前节点：pred，上一个节点：e，下一个节点：null)<br>        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);<br>        <span class="hljs-regexp">//</span>如果pred为null则说明要在第一个节点前加入此节点<br>        <span class="hljs-keyword">if</span> (pred == null)<br>            <span class="hljs-regexp">//</span>将新节点赋予first<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-regexp">//</span>如果pred不为null则说明要在中间位置加入此节点<br>            <span class="hljs-regexp">//</span>将新节点赋予上个节点的下个节点<br>            pred.<span class="hljs-keyword">next</span> = newNode;<br>        <span class="hljs-regexp">//</span>将当前节点赋予上个节点<br>        pred = newNode;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>如果index下标的节点为null，则index是链表大小(上方判断)<br>    <span class="hljs-keyword">if</span> (succ == null) &#123;<br>        <span class="hljs-regexp">//</span>将上一个节点赋予last<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>如果index下标的节点不为null，则将该节点赋予为上个节点的下个节点<br>        pred.<span class="hljs-keyword">next</span> = succ;<br>        <span class="hljs-regexp">//</span>将上个节点赋予index下标的上个节点<br>        succ.prev = pred;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>size + 数组长度<br>    size += numNew;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>    return true;<br>&#125;<br><span class="hljs-regexp">//</span>在最后加入集合<br>public boolean addAll(Collection&lt;? extends E&gt; c) &#123;<br>    return addAll(size, c);<br>&#125;<br><span class="hljs-regexp">//</span>清空链表<br>public void clear() &#123;<br>    <span class="hljs-regexp">//</span>清除节点之间的所有链接是“不必要的”，但如果丢弃的节点居住在一代以上，即使有一个可到达的迭代器，也肯定会释放内存，这有助于一代GC。<br>    <span class="hljs-regexp">//</span> Clearing all of the links between nodes is <span class="hljs-string">&quot;unnecessary&quot;</span>, but:<br>    <span class="hljs-regexp">//</span> - helps a generational GC <span class="hljs-keyword">if</span> the discarded nodes inhabit<br>    <span class="hljs-regexp">//</span>   more than one generation<br>    <span class="hljs-regexp">//</span> - is sure to free memory even <span class="hljs-keyword">if</span> there is a reachable Iterator<br>    <span class="hljs-regexp">//</span>遍历去除强引用，使gc下次回收<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; ) &#123;<br>        Node&lt;E&gt; <span class="hljs-keyword">next</span> = x.<span class="hljs-keyword">next</span>;<br>        x.item = null;<br>        x.<span class="hljs-keyword">next</span> = null;<br>        x.prev = null;<br>        x = <span class="hljs-keyword">next</span>;<br>    &#125;<br>    <span class="hljs-regexp">//</span>去除强引用，使gc下次回收<br>    first = last = null;<br>    <span class="hljs-regexp">//</span>大小置<br>    size = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span>修改次数+<span class="hljs-number">1</span><br>    modCount++;<br>&#125;<br><span class="hljs-regexp">//</span>根据下标获得值<br>public E get(int index) &#123;<br>    <span class="hljs-regexp">//</span>检查下标是否为有值下标<br>    checkElementIndex(index);<br>    <span class="hljs-regexp">//</span>node(index)查询节点，然后返回值<br>    return node(index).item;<br>&#125;<br><span class="hljs-regexp">//</span>在下标处设置值<br>public E set(int index, E element) &#123;<br>    <span class="hljs-regexp">//</span>检查下标是否为有值下标<br>    checkElementIndex(index);<br>    <span class="hljs-regexp">//</span>根绝小标获取节点<br>    Node&lt;E&gt; x = node(index);<br>    <span class="hljs-regexp">//</span>旧值<br>    E oldVal = x.item;<br>    <span class="hljs-regexp">//</span>新值<br>    x.item = element;<br>    <span class="hljs-regexp">//</span>返回旧值<br>    return oldVal;<br>&#125;<br><span class="hljs-regexp">//</span>在下标处添加值<br>public void add(int index, E element) &#123;<br>    <span class="hljs-regexp">//</span>检查下标是否为添加操作的有效位置的索引<br>    checkPositionIndex(index);<br><br>    <span class="hljs-regexp">//</span>如果下标等于链表大小，则说明加入在最后<br>    <span class="hljs-keyword">if</span> (index == size)<br>        <span class="hljs-regexp">//</span>将值加入在最后<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-regexp">//</span>如果下标不等于链表大小则说明要在该下标之前加入<br>        linkBefore(element, node(index));<br>&#125;<br><span class="hljs-regexp">//</span>移除下标对应的节点<br>public E remove(int index) &#123;<br>    <span class="hljs-regexp">//</span>检查下标是否为有值下标<br>    checkElementIndex(index);<br>    <span class="hljs-regexp">//</span>移除该节点<br>    return unlink(node(index));<br>&#125;<br><span class="hljs-regexp">//</span>返回第一个节点，但不删除，如果为null则返回null<br>public E peek() &#123;<br>    final Node&lt;E&gt; f = first;<br>    return (f == null) ? null : f.item;<br>&#125;<br><span class="hljs-regexp">//</span>返回第一个节点，如果为null则返回null，与peek()无区别<br>public E peekFirst() &#123;<br>    final Node&lt;E&gt; f = first;<br>    return (f == null) ? null : f.item;<br>&#125;<br><span class="hljs-regexp">//</span>返回最后一个节点的值<br>public E peekLast() &#123;<br>    final Node&lt;E&gt; l = last;<br>    return (l == null) ? null : l.item;<br>&#125;<br><span class="hljs-regexp">//</span>返回第一个节点的值(如果为空链则异常，与getFirst()无区别)<br>public E element() &#123;<br>    <span class="hljs-regexp">//</span>调用getFirst()<br>    return getFirst();<br>&#125;<br><span class="hljs-regexp">//</span>查询第一个节点的值并删除(简而言之：出栈)<br>public E poll() &#123;<br>    final Node&lt;E&gt; f = first;<br>    return (f == null) ? null : unlinkFirst(f);<br>&#125;<br><span class="hljs-regexp">//</span>查询第一个节点的值并删除(简而言之：出栈，与pollFirst()无区别)<br>public E pollFirst() &#123;<br>    final Node&lt;E&gt; f = first;<br>    return (f == null) ? null : unlinkFirst(f);<br>&#125;<br><span class="hljs-regexp">//</span>查询最后一个节点的值并删除<br>public E pollLast() &#123;<br>    final Node&lt;E&gt; l = last;<br>    return (l == null) ? null : unlinkLast(l);<br>&#125;<br><span class="hljs-regexp">//</span>查询最后一个节点的值并删除<br>public E remove() &#123;<br>    return removeFirst();<br>&#125;<br><span class="hljs-regexp">//</span>添加到最后一个节点(不知道与add(o)有什么区别)<br>public boolean offer(E e) &#123;<br>    return add(e);<br>&#125;<br><span class="hljs-regexp">//</span>添加到第一个节点(与addFirst(o)无区别)<br>public boolean offerFirst(E e) &#123;<br>    addFirst(e);<br>    return true;<br>&#125;<br><span class="hljs-regexp">//</span>添加到最后一个节点(与addLast(o)无区别)<br> public boolean offerLast(E e) &#123;<br>    addLast(e);<br>    return true;<br>&#125;<br><span class="hljs-regexp">//</span>添加到第一个节点(简而言之：入栈)<br>public void push(E e) &#123;<br>    addFirst(e);<br>&#125;<br><span class="hljs-regexp">//</span>返回值并删除第一个节点(简而言之：出栈)<br>public E pop() &#123;<br>    return removeFirst();<br>&#125;<br><span class="hljs-regexp">//</span>删除第一个值为o的节点<br>public boolean removeFirstOccurrence(Object o) &#123;<br>    return remove(o);<br>&#125;<br><span class="hljs-regexp">//</span>删除最后一个值为o的节点<br>public boolean removeLastOccurrence(Object o) &#123;<br>    <span class="hljs-regexp">//</span>判断o是否为null<br>    <span class="hljs-keyword">if</span> (o == null) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == null) &#123;<br>                <span class="hljs-regexp">//</span>删除该节点<br>                unlink(x);<br>                return true;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span>如果o不为null<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                <span class="hljs-regexp">//</span>删除该节点<br>                unlink(x);<br>                return true;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return false;<br>&#125;<br><span class="hljs-regexp">//</span>获取迭代器<br>public ListIterator&lt;E&gt; listIterator(int index) &#123;<br>    <span class="hljs-regexp">//</span>检查是否为迭代器或添加操作的有效位置的索引<br>    checkPositionIndex(index);<br>    返回迭代器<br>    return new ListItr(index);<br>&#125;<br><span class="hljs-regexp">//</span>转换为数组(与ArrayList不同，ArrayList是通过JNI调用本地方法，LinkedList是自己转换)<br>public Object[] toArray() &#123;<br>    <span class="hljs-regexp">//</span>新建一个链表大小的数组<br>    Object[] result = new Object[size];<br>    int i = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span>遍历并放入数组中<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>)<br>        result[i++] = x.item;<br>    return result;<br>&#125;<br><span class="hljs-regexp">//</span>将链表的值放入数组a中<br>public &lt;T&gt; T[] toArray(T[] a) &#123;<br>    <span class="hljs-regexp">//</span>如果a数组的大小小于链表大小<br>    <span class="hljs-keyword">if</span> (a.length &lt; size)<br>        a = (T[])java.lang.reflect.Array.newInstance(<br>                            a.getClass().getComponentType(), size);<br>    int i = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span>将数组a的地址赋予result<br>    Object[] result = a;<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.<span class="hljs-keyword">next</span>)<br>        <span class="hljs-regexp">//</span>将链表的数据放入result中<br>        result[i++] = x.item;<br><br>    <span class="hljs-regexp">//</span>如果数组a的长度是大于链表大小的，则将a[size]置为null(之前的操作并不会遍历到size下标)<br>    <span class="hljs-keyword">if</span> (a.length &gt; size)<br>        a[size] = null;<br>    <span class="hljs-regexp">//</span>返回数组a(操作result即操作a吗，因为a的地址赋予给了result)<br>    return a;<br>&#125;<br></code></pre></td></tr></table></figure><p>#总结<br>1.LinkedList允许存在重复的值<br>2.LinkedList允许存在多个null值<br>3.remove(o)只会删除第一个o值<br>4.indexOf(o)只会返回第一值为o的下标<br>5.尽量减少使用查询的行为，因为查询行为是遍历所有，时间复杂度为O(n)<br>6.查询少，修改多的地方可使用 例：栈(完美)<br>7.虽说LinkedList更适合修改场景，但是每次修改是都会通过node(index)进行查询，所以效率还是会有所降低，不过不可避免<br>8.通过add(),remove()方法可发现修改场景为：node(查询节点，然后增加一个节点即可)<br>9.add(),addLast(),offer(),offerLast()是一样的</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>jdk</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="/2018/01/16/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2018/01/16/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>此源码分析JDK版本为1.7，只是简单分析，算是个人看源码的一点小总结，随意性比较强，专业的还需百度。<br>先简单介绍一下ArrayList，ArrayList为线性数据结构，时间复杂度为O(1)，内部存储为数组。以下所有表达ArrayList的内容统称为数组。<br>ps:ArrayList和Vector的区别就是ArrayList是线程不安全的，Vector是线程安全的。Vector底层核心方法都为synchronized。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList&lt;E&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList&lt;E&gt;</span></span><br>        implements <span class="hljs-type">List</span>&lt;<span class="hljs-type">E</span>&gt;, <span class="hljs-type">RandomAccess</span>, <span class="hljs-type">Cloneable</span>, java.io.<span class="hljs-type">Serializable</span><br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//默认数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//默认空数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span>[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//数组(ArrayList中的数据就放在此数组中)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-built_in">Object</span>[] elementData;<br><span class="hljs-comment">//数组真实数据的长度(与数组的长度不一样)</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-built_in">size</span>;<br><span class="hljs-comment">//数组最大大小常量(Integer.MAX_VALUE - 8原因是尝试分配较大的数组可能会导致OutOfMemoryError)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MAX_ARRAY_SIZE = Integer.<span class="hljs-property">MAX_VALUE</span> - <span class="hljs-number">8</span>;<br><span class="hljs-comment">//修改次数(对于线程安全至关重要，在Iterator中会解释)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>#构造方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//无初始化长度的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-comment">//将属性中的空数组赋给elementData</span><br>    <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>&#125;<br><span class="hljs-comment">//初始化长度的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-comment">//当初始化长度小于0则抛出异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>    <span class="hljs-comment">//new该长度的Object数组给与elementData</span><br>    <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>&#125;<br><span class="hljs-comment">//根据父类Collection类型的对象进行构造的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-comment">//不同的Collection的实现类会有不同的实现，但最终结果都是转为Object数组</span><br>    elementData = c.<span class="hljs-built_in">toArray</span>();<br>    size = elementData.length;<br>    <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>    <span class="hljs-keyword">if</span> (elementData.<span class="hljs-built_in">getClass</span>() != Object[].<span class="hljs-keyword">class</span>)<br>    <span class="hljs-comment">//目前未知(属性定义为Object，判断不等于因此觉得不太理解，而且debug各种类型都是直接跳过此方法，暂时觉得此判断不会进入)</span><br>    elementData = Arrays.<span class="hljs-built_in">copyOf</span>(elementData, size, Object[].<span class="hljs-keyword">class</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//返回数组大小</span><br><span class="hljs-keyword">public</span> int <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><span class="hljs-comment">//是否为空</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//获取该值的下标(无返回-1)</span><br><span class="hljs-keyword">public</span> int <span class="hljs-title function_">indexOf</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-comment">//可能会有人说Object默认的equals()实现是==，觉得此方法块没意义，但实际调用的为真实类型的equals()方法</span><br>            <span class="hljs-keyword">if</span> (o.<span class="hljs-title function_">equals</span>(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//获取最后该值的下标(无返回-1)</span><br><span class="hljs-keyword">public</span> int <span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (int i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (int i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-comment">//同上</span><br>            <span class="hljs-keyword">if</span> (o.<span class="hljs-title function_">equals</span>(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//是否包含</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">contains</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">indexOf</span>(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//返回数组(并不是返回Object数组，而是真实类型的数组)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-title function_">toArray</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//查看copyOf源码会发现返回的是真实类型数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">copyOf</span>(elementData, size);<br>&#125;<br><span class="hljs-comment">//当调用get()时会通过此方法返回值 (default，外部无法调用)</span><br>E <span class="hljs-title function_">elementData</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br><span class="hljs-comment">//检查传入的下标参数是否越界</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">rangeCheck</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-title function_">outOfBoundsMsg</span>(index));<br>&#125;<br><span class="hljs-comment">//返回该下标所对应的值</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-comment">//检查下标参数是否越界</span><br>    <span class="hljs-title function_">rangeCheck</span>(index);<br><br>    <span class="hljs-comment">//根据下标返回值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">elementData</span>(index);<br>&#125;<br><span class="hljs-comment">//设置下标和值</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span>(<span class="hljs-params">int index, E element</span>) &#123;<br>    <span class="hljs-comment">//检查下标参数是否越界</span><br>    <span class="hljs-title function_">rangeCheck</span>(index);<br><br>    <span class="hljs-comment">//获取该下标的值</span><br>    E oldValue = <span class="hljs-title function_">elementData</span>(index);<br>    <span class="hljs-comment">//为该下标赋新值</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">//返回旧值</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><span class="hljs-comment">//扩容：第一步将传入的值与默认最小值进行对比</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;<br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">EMPTY_ELEMENTDATA</span>) &#123;<br>        <span class="hljs-comment">//最小为默认最小值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">//扩容实现</span><br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);<br>&#125;<br><span class="hljs-comment">//扩容：第二步将第一步的值与数组大小进行对比判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span>(<span class="hljs-params">int minCapacity</span>) &#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-comment">//当传入的值大于数组长度时，进行扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">grow</span>(minCapacity);<br>&#125;<br><span class="hljs-comment">//扩容：扩容真正实现(默认情况下扩容之后的大小为当前数组长度+数组对2取余)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">grow</span>(<span class="hljs-params">int minCapacity</span>) &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    int oldCapacity = elementData.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">//定义变量为当前大小加一半取余</span><br>    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果变量小于传的参数，则新的数组大小为传入的参数</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">//如果变量大于数组默认最大值则调用hugeCapacity()方法返回值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - <span class="hljs-variable constant_">MAX_ARRAY_SIZE</span> &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//将新的数组大小与默认最大值进行对比</span><br>        newCapacity = <span class="hljs-title function_">hugeCapacity</span>(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <span class="hljs-comment">//调用Arrays.copyOf()扩容</span><br>    elementData = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">copyOf</span>(elementData, newCapacity);<br>&#125;<br><span class="hljs-attr">tag</span>:第一个判断:如果传入的值小于[数组大小加对二取余]则新的数组大小为传入的值，定义的新值为传入的值；如果不是则无操作。第二个判断:第一步运算厚的结果如果大于默认数组最大长度，则返回<span class="hljs-title function_">hugeCapacity</span>()计算后的值；如果不是则无操作<br><span class="hljs-comment">//判断传的值是否大于默认数组最大长度，如果是则为Integer最大值；如果不是则为默认数组最大长度，返回可用大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> int <span class="hljs-title function_">hugeCapacity</span>(<span class="hljs-params">int minCapacity</span>) &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; <span class="hljs-variable constant_">MAX_ARRAY_SIZE</span>) ?<br>        <span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span> :<br>        <span class="hljs-variable constant_">MAX_ARRAY_SIZE</span>;<br>&#125;<br><span class="hljs-comment">//在数组中增加值</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">E e</span>) &#123;<br>    <span class="hljs-comment">//添加则会增加modCount</span><br>    <span class="hljs-title function_">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//为某个下标新增值</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">int index, E element</span>) &#123;<br>    <span class="hljs-comment">//判断下标是否越界</span><br>    <span class="hljs-title function_">rangeCheckForAdd</span>(index);<br><br>    <span class="hljs-comment">//先扩容(防止index刚好为当前数组长度)</span><br>    <span class="hljs-title function_">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//将源数组index位置开始的数组复制到目标数组index+1后，复制的数量为size-index个</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br><span class="hljs-comment">//删除某下标对应的值</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-comment">//判断下标是否越界</span><br>    <span class="hljs-title function_">rangeCheck</span>(index);<br><br>    <span class="hljs-comment">//增加修改次数</span><br>    modCount++;<br>    <span class="hljs-comment">//获取旧值</span><br>    E oldValue = <span class="hljs-title function_">elementData</span>(index);<br><br>    <span class="hljs-comment">//判断删除该下标元素需要向前移动多少个位置</span><br>    int numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//如果当前下标不是最后一个元素，则将源数组index+1位置开始的数组复制到目标数组index后，复制的数量为numMoved个</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work  //置空原尾部数据 不再强引用， 可以GC掉</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><span class="hljs-comment">//根据下标删除值(不检查下标是否越界)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fastRemove</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-comment">//增加修改次数</span><br>    modCount++;<br>    int numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work  //置空原尾部数据 不再强引用， 可以GC掉</span><br>&#125;<br><span class="hljs-comment">//删除值(只删除第一个)</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (int index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//调用不检查下标删除值</span><br>                <span class="hljs-title function_">fastRemove</span>(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (int index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.<span class="hljs-title function_">equals</span>(elementData[index])) &#123;<br>                <span class="hljs-comment">//调用不检查下标删除值</span><br>                <span class="hljs-title function_">fastRemove</span>(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//清空数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//增加修改次数</span><br>    modCount++;<br><br>    <span class="hljs-comment">// clear to let GC do its work  //置空原尾部数据 不再强引用， 可以GC掉</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        elementData[i] = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//数组真实长度归零</span><br>    size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//将Collection增加到当前数组之后</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c</span>) &#123;<br>    <span class="hljs-title class_">Object</span>[] a = c.<span class="hljs-title function_">toArray</span>();<br>    int numNew = a.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">//扩容大小为当前数组长度加参数数组长度</span><br>    <span class="hljs-title function_">ensureCapacityInternal</span>(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(a, <span class="hljs-number">0</span>, elementData, size, numNew);<br>    <span class="hljs-comment">//设置真实数组大小长度</span><br>    size += numNew;<br>    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//判断增加下标是否越界(与判断是否越界区别在于少了=size和增加了不小于0)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">rangeCheckForAdd</span>(<span class="hljs-params">int index</span>) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-title function_">outOfBoundsMsg</span>(index));<br>&#125;<br><span class="hljs-comment">//在下标后增加Collection</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">int index, Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c</span>) &#123;<br>    <span class="hljs-comment">//判断增加下标是否越界</span><br>    <span class="hljs-title function_">rangeCheckForAdd</span>(index);<br><br>    <span class="hljs-title class_">Object</span>[] a = c.<span class="hljs-title function_">toArray</span>();<br>    int numNew = a.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">//扩容大小为当前数组长度加参数数组长度</span><br>    <span class="hljs-title function_">ensureCapacityInternal</span>(size + numNew);  <span class="hljs-comment">// Increments modCount</span><br><br>    <span class="hljs-comment">//位移量</span><br>    int numMoved = size - index;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//将index之后的位移量numNoved空置出来</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, index, elementData, index + numNew,<br>                         numMoved);<br>    <span class="hljs-comment">//将Collection的数组放置index之后index + numNew之前</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(a, <span class="hljs-number">0</span>, elementData, index, numNew);<br>    <span class="hljs-comment">//设置真实数组大小长度</span><br>    size += numNew;<br>    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//删除指定区间内的数组内容(protected修饰，subList方法会调用，外部不可访问)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">removeRange</span>(<span class="hljs-params">int fromIndex, int toIndex</span>) &#123;<br>    <span class="hljs-comment">//增加修改次数</span><br>    modCount++;<br>    <span class="hljs-comment">//计算位移量</span><br>    int numMoved = size - toIndex;<br>    <span class="hljs-comment">//将toIndex后的数组放置fromIndex之后</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, toIndex, elementData, fromIndex,<br>                     numMoved);<br><br>    <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-comment">//计算应当删除的起始下标</span><br>    int newSize = size - (toIndex-fromIndex);<br>    <span class="hljs-keyword">for</span> (int i = newSize; i &lt; size; i++) &#123;<br>        elementData[i] = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//设置真实数组大小长度</span><br>    size = newSize;<br>&#125;<br><span class="hljs-comment">//与Collection取交集</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">retainAll</span>(<span class="hljs-params">Collection&lt;?&gt; c</span>) &#123;<br>    <span class="hljs-comment">//实际调用，true表示取交集</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchRemove</span>(c, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">//根据complement决定取交集还是取非交集(注意this.elementDat和elementData )</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">batchRemove</span>(<span class="hljs-params">Collection&lt;?&gt; c, <span class="hljs-built_in">boolean</span> complement</span>) &#123;<br>    <span class="hljs-comment">//定义变量</span><br>    final <span class="hljs-title class_">Object</span>[] elementData = <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span>;<br>    <span class="hljs-comment">//为了方便理解可以理解为:r为this.elementData的下标，w为elementData 下标</span><br>    int r = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义是否修改成功</span><br>    <span class="hljs-built_in">boolean</span> modified = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (; r &lt; size; r++)<br>            <span class="hljs-comment">//根据complement决定是否将此值放入elementData中</span><br>            <span class="hljs-keyword">if</span> (c.<span class="hljs-title function_">contains</span>(elementData[r]) == complement)<br>                <span class="hljs-comment">//w++是将值放入下标为w之后w再+1</span><br>                elementData[w++] = elementData[r];<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Preserve behavioral compatibility with AbstractCollection,</span><br>        <span class="hljs-comment">// even if c.contains() throws.</span><br>        <span class="hljs-comment">//如果c.contains()抛出异常是则r一定不等于size，则执行下方。将this.elementData下标r之后的复制到elementData下标w之后</span><br>        <span class="hljs-keyword">if</span> (r != size) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-title function_">arraycopy</span>(elementData, r,<br>                             elementData, w,<br>                             size - r);<br>            w += size - r;<br>        &#125;<br>        <span class="hljs-comment">//如果w!=size则需要将w之后的数组清楚</span><br>        <span class="hljs-keyword">if</span> (w != size) &#123;<br>            <span class="hljs-comment">// clear to let GC do its work</span><br>            <span class="hljs-keyword">for</span> (int i = w; i &lt; size; i++)<br>                elementData[i] = <span class="hljs-literal">null</span>;<br>                modCount += size - w;<br>                size = w;<br>                <span class="hljs-comment">//只有进入此代码块才表明修改成功</span><br>                modified = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> modified;<br>&#125;<br><span class="hljs-comment">//返回Itr迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; <span class="hljs-title function_">iterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br><span class="hljs-comment">//返回ListItr迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; <span class="hljs-title function_">listIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//subList部分放置在ArrayList-SubList文章中</span><br><span class="hljs-attr">tag</span>:在上段代码中，只有w!=size的情况下才会表明修改成功。我的理解：首先，<span class="hljs-title function_">contains</span>()发生异常只会是空指针。如果相等则可能发生以下几种情况<span class="hljs-number">1.</span>求交集但两个数组完全一样<span class="hljs-number">2.</span>求非交集两个数组完全不一样<span class="hljs-number">3.</span>从开始就出现异常<br></code></pre></td></tr></table></figure><p>#总结</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>.ArrayList增删实现基本靠System.arraycopy()实现，修改是通过数组下标(只能在下标范围内修改)<br><span class="hljs-number">2</span>.通过modCount解决线程安全问题(iterator遍历时如果修改则会直接抛出异常)<br><span class="hljs-number">3</span>.手动置<span class="hljs-keyword">null</span>去除强引用使<span class="hljs-keyword">gc</span>下次工作是回收此对象<br><span class="hljs-number">4</span>.增、删都会因为数组扩容二影响效率，修改和查询不会影响效率<br><span class="hljs-number">5</span>.增、删都会修改modCount，修改和查询不会修改modCount<br><span class="hljs-number">6</span>.手动置<span class="hljs-keyword">null</span>只是将内存地址取消引用，因为<span class="hljs-keyword">gc</span>是通过计数法来进行回收，当内存地址没有被引用就会被回收<br></code></pre></td></tr></table></figure><h2 id="ArrayList-Iterator源码分析"><a href="#ArrayList-Iterator源码分析" class="headerlink" title="ArrayList-Iterator源码分析"></a>ArrayList-Iterator源码分析</h2><p>此源码分析JDK版本为1.7，只是简单分析，算是个人看源码的一点小总结，随意性比较强，专业的还需百度。<br>#private class Itr implements Iterator<E>{}<br>##简介<br>私有内部类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Itr</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Iterator</span>&lt;<span class="hljs-symbol">E</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//下一个元素返回的索引</span><br><span class="hljs-type">int</span> cursor;<br><span class="hljs-comment">//遍历上个元素的索引 如果没有则返回-1</span><br><span class="hljs-type">int</span> lastRet = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//当前修改次数(参考ArrayList的modCount属性)</span><br><span class="hljs-type">int</span> expectedModCount = modCount;<br></code></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无<br></code></pre></td></tr></table></figure><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//判断是否还有下一个</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//通过判断下一个下标是否为数组大小即可得出结果</span><br>    <span class="hljs-keyword">return</span> cursor != size;<br>&#125;<br><span class="hljs-comment">//检查当前Itr修改次数和ArrayList是否一致，不一致则抛异常(并发异常) ps:final是防止子类覆盖此方法(ListItr)</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>&#125;<br><span class="hljs-comment">//获取下一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//检查修改次数是否一致</span><br>    <span class="hljs-built_in">checkForComodification</span>();<br>    <span class="hljs-comment">//定义i为下个元素的下标</span><br>    <span class="hljs-type">int</span> i = cursor;<br>    <span class="hljs-comment">//下标判断</span><br>    <span class="hljs-keyword">if</span> (i &gt;= size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NoSuchElementException</span>();<br>    <span class="hljs-comment">//定义elementData为ArrayList的数组</span><br>    Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>    <span class="hljs-comment">//再次下标判断，此次判断不一致则说明数组修改过，抛出异常(并发异常)</span><br>    <span class="hljs-comment">//可能出现的场景1.ArrayList的remove()方法中中elementData[--size] = null，size--之前进入了此方法</span><br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>    <span class="hljs-comment">//定义下个元素的下标</span><br>    cursor = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//将lastRet定义为下个元素的下标(返回的最后一个元素的下标)，返回该下标对应的值</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br><span class="hljs-comment">//移出当前元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//如果无当前遍历元素则抛出异常</span><br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalStateException</span>();<br>    <span class="hljs-comment">//检查修改次数是否一致</span><br>    <span class="hljs-built_in">checkForComodification</span>();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//调用ArrayList的remove方法(如果在遍历外remove会导致Itr中的expectedModCount没有修改抛异常)</span><br>        ArrayList.<span class="hljs-keyword">this</span>.<span class="hljs-built_in">remove</span>(lastRet);<br>        <span class="hljs-comment">//定义下一个元素的下标为当前下标</span><br>        cursor = lastRet;<br>        <span class="hljs-comment">//定义上个遍历下标为-1</span><br>        lastRet = <span class="hljs-number">-1</span>;<br>        expectedModCount = modCount;<br>    &#125; <span class="hljs-built_in">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#private class ListItr extends Itr implements ListIterator<E> {}</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>继承Itr的顺序遍历，自己封装的逆序遍历<br>逆序遍历是从构造方法传参的下标开始往上遍历(默认的构造方法传参为0，无法逆序遍历)<br>可以说ListItr存在的意义就是逆序遍历、set()和add()，如果不使用逆序遍历完全可以使用Itr</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Itr</span> <span class="hljs-title">implements</span> <span class="hljs-title">ListIterator&lt;E&gt;</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">继承Itr<br></code></pre></td></tr></table></figure><p>##构造方法(参数一般为数组的长度)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">ListItr(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>) &#123;<br>        <span class="hljs-keyword">super</span>();<br>        cursor = <span class="hljs-keyword">index</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//是否拥有上一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cursor != <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//下一个元素下标</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cursor;<br>&#125;<br><span class="hljs-comment">//上一个元素下标</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cursor - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//获取上一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//检查修改次数是否一致</span><br>    <span class="hljs-built_in">checkForComodification</span>();<br>    <span class="hljs-comment">//定义i为上个元素的下标</span><br>    <span class="hljs-type">int</span> i = cursor - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//下标判断</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NoSuchElementException</span>();<br>    <span class="hljs-comment">//定义elementData为ArrayList的数组</span><br>    Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>    <span class="hljs-comment">//可能出现的场景1.ArrayList的remove()方法中中elementData[--size] = null，size--之前进入了此方法</span><br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>    <span class="hljs-comment">//定义上个元素的下标</span><br>    cursor = i;<br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br><span class="hljs-comment">//为当前下标重新赋值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalStateException</span>();<br>    <span class="hljs-comment">//检查修改次数是否一致</span><br>    <span class="hljs-built_in">checkForComodification</span>();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//调用ArrayList的set方法(如果在遍历外set会导致Itr中的expectedModCount没有修改抛异常)</span><br>        ArrayList.<span class="hljs-keyword">this</span>.<span class="hljs-built_in">set</span>(lastRet, e);<br>    &#125; <span class="hljs-built_in">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//为当前下标后增加值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">//检查修改次数是否一致</span><br>    <span class="hljs-built_in">checkForComodification</span>();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> i = cursor;<br>        <span class="hljs-comment">//调用ArrayList的add方法(如果在遍历外add会导致Itr中的expectedModCount没有修改抛异常)</span><br>        ArrayList.<span class="hljs-keyword">this</span>.<span class="hljs-built_in">add</span>(i, e);<br>        cursor = i + <span class="hljs-number">1</span>;<br>        lastRet = <span class="hljs-number">-1</span>;<br>        expectedModCount = modCount;<br>    &#125; <span class="hljs-built_in">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.在Iterator遍历时，对<span class="hljs-keyword">list</span>进行set操作并不会抛出异常，也就是说存在脏数据问题<br><span class="hljs-number">2</span>.ListItr在Itr的基础上增加了逆序遍历、set()和add()<br><span class="hljs-number">3</span>.在遍历时对ArrayList的add和<span class="hljs-comment">remove操作应该使用Itr或者其子类完成，防止出现ConcurrentModificationException</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>jdk</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
